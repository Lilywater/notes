
* firefox related

https://developer.mozilla.org/En/Developer_Guide


** sourcecode,
https://developer.mozilla.org/En/Developer_Guide/Build_Instructions
1. apt-get build-dep firefox
apt-get install mercurial libasound2-dev libcurl4-openssl-dev libnotify-dev libxt-dev libiw-dev mesa-common-dev autoconf2.13 yasm

On a non-Macintosh build system, the finished build can be found in objdir/dist/bin. On POSIX platforms (BSD, GNU/Linux, Solaris), you should run the file "mozilla" or "firefox", not the binary "mozilla-bin" or "firefox-bin".


** xulrunner tutorial
https://developer.mozilla.org/en/getting_started_with_xulrunner

hacking the user interface (graphic)
https://developer.mozilla.org/en/Hacking_Firefox


** firefox 插件安装

tabmix 0.3.8.6
  {dc572301-7619-498c-a57d-39143191b318}

extensions/{dc572301-7619-498c-a57d-39143191b318}/icon.png
zxx@gll-bac:~/.mozilla/firefox/qp8z4ln4.default$



* irc

irc.mozilla.org
irc.freenode.org  //linux related topic
xlsclients -l
xdottool  windowunmap

https://wiki.mozilla.org/IRC
 Practically, you start from terminal with command: irssi
 then: /server irc.mozilla.org
/join #firefox


http://stackoverflow.com/questions/1029027/x11-move-an-existing-window-via-command-line
xlsclients
xdotool windowunmap
xdotool windowmap  
 pmap -x `pidof firefox-bin` |grep gtk
ld-desktop$ ldd qtfire
	libQtGui.so.4 => /usr/lib/libQtGui.so.4 (0x002df000)
	libQtCore.so.4 => /usr/lib/libQtCore.so.4 (0x00d5b000)
	libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0x00110000)
	libstdc++.so.6 => /usr/lib/libstdc++.so.6 (0x001bf000)
	libm.so.6 => /lib/tls/i686/cmov/libm.so.6 (0x00129000)
	libgcc_s.so.1 => /lib/libgcc_s.so.1 (0x0014f000)
	libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0x00fd9000)
	libfontconfig.so.1 => /usr/lib/libfontconfig.so.1 (0x0e553000)
	libaudio.so.2 => /usr/lib/libaudio.so.2 (0x00191000)


//system("kill  `ps aux|grep firefox| awk '{print $2}' `");

gcc gtkw.c -o gtkw `pkg-config --cflags --libs gtk+-2.0`  
gcc xtest.c -L /usr/X11R6/lib -lX11  -lgcrypt -lstdc++


http://xopendisplay.hilltopia.ca/2009/Jan/Xlib-tutorial-part-1----Beginnings.html

http://faq.pygtk.org/index.py?req=show&file=faq23.024.htp
23.24. Can GTK know the mouse position outside of GTK Application?
To get the position relative to a given window


  gdkwindow.get_pointer() 

If you need the absolute position, call get_pointer on the root window of the current screen:

  rootwin = widget.get_screen().get_root_window()
  x, y, mods = rootwin.get_pointer()


xprop -root|grep "_NET_CLIENT_LIST_STACKING(WINDOW): window id"|cut -d\ -f 5
http://www.ibm.com/developerworks/cn/linux/l-cn-qt/


* qnx-bsp-board
你可以用下面的命令在根目录下创建一个你需要的目录：

                devb-ram cam quiet disk name=.ram@1 ram capacity=0,nodinit blk ramdisk=10m,cache=0,vnode=256
                dinit -q -h /dev/ram0
                mount -tqnx4 /dev/ram0   /yourDirectoryName

除了devb-ram, dinit,等命令外，你还需要加上如下的库

cam-disk.so
fs-qnx4.so
io-blk.so

* meego related

madde环境的搭建
liguo@lili:/usr/lib/madde/linux-i686$ ls
bin    legal   madlib            run       sysroots  templates   tools
cache  madbin  postinstall.done  runtimes  targets   toolchains

cache存放从网上下载的安装文件
madde 提供交叉编因环境： target  sysroot （含有qt在目标机上编译时的库，头文件，以对应文件夹的形式存在）
                       运行环境：   runtime   （运行环境相当于linux的root filesystem，以一个文件raw等格式存在）
所以在安装target和runtime时需要匹配。

mad-admin list 
mad remote -r <highlight>meego-handset-ia32-qemu-1.1.20101031.2201-sda-runtime</highlight> poweron
这个runtime名称在runtimes文件夹里。



Qtcreator配置的meego编译环境里实际上是利用：
$ mad pscreate -l
TEMPLATE NAME    TYPE     DESCRIPTION
lib-simple       lib      Simple example for C/C++ library
python           python   Simple example for Python (Qt) application
qt-empty         prog     Empty project for Qt application
qt-lib-simple    lib      Simple example for Qt library
qt-simple        qtprog   Simple example for Qt application
simple           prog     Simple example for C/C++ application

$ mad -t meego-handset-ia32-1.1 pscreate -t qt-simple test-rpm-0.0.1
$ cd test-rpm-0.0.1/
$ mad -t meego-handset-ia32-1.1 qmake
$ mad -t meego-handset-ia32-1.1 make
打包：
Package Creation: Running command 'rrpmbuild -bb cbook.spec'.
命令rrpmbuild是在 <link:url>/usr/lib/madde/linux-i686/madbin/rrpmbuild</link:url> 这个文件夹下 make install
实质是install就是把文件拷贝到相应的目录下，实际只要在Makefile中指定install就可以完成了，在qt中，则在pro文件中设置即可
TARGET = cbook
target.path=/usr/local/bin
INSTALLS +=target

INSTALLS    += desktop
desktop.path  = <link:url>/usr/share/applications</link:url>
desktop.files  = ../cbook.desktop


INSTALLS    += icon64
icon64.path  = <link:url>/usr/share/icons/hicolor/64x64/apps</link:url>
icon64.files  = ../icons/cbook_icon.png



<bold>愷风的专栏
<link:url>http://blog.csdn.net/flowingflying/category/526791.aspx?PageNumber=2</link:url></bold>

x windows的方式: ssh -X meego@localhost -p 6666 。这样当我运行一个带界面的程序，在另一个窗口弹出界面程序。



    sudo rpm -i --force qthello-0.0.1-1.i586.rpm &amp;& sudo sudo chmod a+x <link:url>/usr/local/bin/qthello</link:url> &amp;& source <link:url>/etc/profile</link:url> &amp;& export DISPLAY=:0  &amp;& sudo su -m meego -c 'xhost + ';   <link:url>/usr/local/bin/qthello</link:url> ;echo Ꭰ

　　步骤如下：

1. 打开ssh，例如ssh  root@localhost -p 6666，

2. 此前，在通过QtCreator中，已经将qthello的rpm下载到i㎎中，并已经安装好.

3. 在ssh的命令行中，输入：# export DISPLAY=:0 ，这样，设置好环境，可以通过运行# qthello或者# <link:url>/usr/local/bin/qthello，就可以在模拟器中显示</link:url>。



 3  pkill -x test;pkill -x gdbserver;sleep 1; pkill -x -9 test;pkill -x -9 gdbserver;echo Ꭰ
    4  sudo rpm -i --force test-0.0.1-1.i586.rpm &amp;& sudo sudo chmod a+x <link:url>/usr/local/bin/test</link:url> &amp;& source <link:url>/etc/profile</link:url> &amp;& export DISPLAY=:0 &amp;& sudo su -m meego -c 'xhost +';   gdbserver :13219 <link:url>/usr/local/bin/test</link:url> ;echo Ꭰ


gdbserver 和 gdb 在qt中的运用，模拟如下：
在目标机上：meego@[meego-handset-sdk]::~$ gdbserver 127.0.0.1:13219 <link:url>/usr/local/bin/cbook</link:url> 
Process <link:url>/usr/local/bin/cbook</link:url> created; pid = 743
Listening on port 13219

在主机上
$ gdb qthello
GNU gdb (GDB) 7.1-ubuntu
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;<link:url>http://gnu.org/licenses/gpl.html</link:url>>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu".
For bug reporting instructions, please see:
<<link:url>http://www.gnu.org/software/gdb/bugs/</link:url>>...
qthello: 没有那个文件或目录.
(gdb) <highlight>target remote 127.0.0.1:13219</highlight>
<size:large>这里就连接主机上的程序了。</size:large>
Remote debugging using 127.0.0.1:13219
warning: Could not load vsyscall page because no executable was specified
try using the "file" command first.
0x4b13d850 in ?? ()
(gdb) continue 



svn ci -m "tech point"

vi <link:url>/etc/zypp/repos.d/core.repo</link:url> 
vi <link:url>/etc/zypp/repos.d/handset.repo</link:url> 
http_proxy added

ofono configure
configure: error: libudev &gt;= 143 is required
zypper install libudev-devel

cat <link:url>/etc/ofono/phonesim.conf</link:url> 
./list-modems 
[ /phonesim ]
    Lockdown = 0
    Interfaces = 
    Powered = 0
    Features = 
    Online = 0


<link:url>root@meego-handset-sdk:~/ofono-0.42/test</link:url># ./enable-modem /phonesim
<link:url>root@meego-handset-sdk:~/ofono-0.42/test</link:url># ./test-voicecall /phonesim 10086


* uboot 命令
** printenv命令 
uboot的启动流程是由uboot的env变量控制的。
---------------------------------
OMAP3 beagleboard.org # printenv
baudrate=115200
beaglerev=xMC
bootcmd=if mmc rescan ${mmcdev}; then if userbutton; then setenv bootenv user.tx
t;fi;echo SD/MMC found on device ${mmcdev};if run loadbootenv; then echo Loaded
environment from ${bootenv};run importbootenv;fi;if test -n $uenvcmd; then echo
Running uenvcmd ...;run uenvcmd;fi;if run loaduimage; then run mmcboot;fi;fi;run
 nandboot;
bootdelay=3
/bootenv=uEnv.txt
buddy=none
camera=lbcm3m1
console=ttyS2,115200n8
defaultdisplay=dvi
dieid#=47ee00029ff80000016830101701e022
dvimode=640x480MR-16@60
importbootenv=echo Importing environment from mmc ...; env import -t $loadaddr $
filesize
loadaddr=0x80200000
loadbootenv=fatload mmc ${mmcdev} ${loadaddr} ${bootenv}
loadramdisk=fatload mmc ${mmcdev} ${rdaddr} ramdisk.gz
loaduimage=ext2load mmc ${mmcdev}:2 ${loadaddr} /boot/uImage
loaduimagefat=fatload mmc ${mmcdev} ${loadaddr} uImage
mmcargs=setenv bootargs console=${console} ${optargs} mpurate=${mpurate} buddy=$
{buddy} camera=${camera} vram=${vram} omapfb.mode=dvi:${dvimode} omapdss.def_dis
p=${defaultdisplay} root=${mmcroot} rootfstype=${mmcrootfstype}
mmcboot=echo Booting from mmc ...; run mmcargs; bootm ${loadaddr}
mmcdev=0
mmcroot=/dev/mmcblk0p2 rw
mmcrootfstype=ext3 rootwait
mpurate=auto
nandargs=setenv bootargs console=${console} ${optargs} mpurate=${mpurate} buddy=
${buddy} camera=${camera} vram=${vram} omapfb.mode=dvi:${dvimode} omapdss.def_di
sp=${defaultdisplay} root=${nandroot} rootfstype=${nandrootfstype}
nandboot=echo Booting from nand ...; run nandargs; nand read ${loadaddr} 280000
400000; bootm ${loadaddr}
nandroot=/dev/mtdblock4 rw
nandrootfstype=jffs2
ramargs=setenv bootargs console=${console} ${optargs} mpurate=${mpurate} buddy=$
{buddy} camera=${camera} vram=${vram} omapfb.mode=dvi:${dvimode} omapdss.def_dis
p=${defaultdisplay} root=${ramroot} rootfstype=${ramrootfstype}
ramboot=echo Booting from ramdisk ...; run ramargs; bootm ${loadaddr}
ramroot=/dev/ram0 rw ramdisk_size=65536 initrd=0x81000000,64M
ramrootfstype=ext2
rdaddr=0x81000000
usbtty=cdc_acm
vram=12M

Environment size: 2092/131068 bytes
OMAP3 beagleboard.org #
--------------------------------------------



启动信息
--------------

Texas Instruments X-Loader 1.5.0 (Mar 27 2011 - 17:37:56)
Beagle xM
Reading boot sector
Loading u-boot.bin from mmc


U-Boot 2011.03-rc1-00000-g9a3cc57-dirty (Apr 01 2011 - 17:41:42)

OMAP3630/3730-GP ES2.1, CPU-OPP2, L3-165MHz, Max CPU Clock 1 Ghz
OMAP3 Beagle board + LPDDR/NAND
I2C:   ready
DRAM:  512 MiB
NAND:  0 MiB
MMC:   OMAP SD/MMC: 0
***Warning - readenv() failed, using default environment

In:    serial
Out:   serial
Err:   serial
Beagle xM Rev C
No EEPROM on expansion board
Die ID #47ee00029ff80000016830101701e022
Hit any key to stop autoboot:  0
The user button is currently NOT pressed.
SD/MMC found on device 0
reading uEnv.txt

107 bytes read
Loaded environment from uEnv.txt
Importing environment from mmc ...
Loading file "/boot/uImage" from mmc device 0:2 (xxa2)
Failed to mount ext2 filesystem...
**Bad ext2 partition or disk - mmc 0:2 **
Booting QNX ...
reading ifs-omap3730-beagle.bin

4926796 bytes read
## Starting application at 0x80100000 ...
Beagle Board Revision: xm_c
Initializing xM's onboard hub and dvi power pin
Enabling USB hub
--------------------------------------

* x window rleated

** x window programing related

1.commands
xlsclients -l
xdotool windowfocus 0x1a00ad2
xdotool windowunmap 'id'

xlsclients -l | grep -B 3 "firefox"   |grep Window|awk '{print $2}'|sed 's/://'
xprop -root|grep "_NET_CLIENT_LIST_STACKING(WINDOW): window id"|cut -d\ -f 5

xwininfo
http://www.ibm.com/developerworks/cn/linux/l-cn-qt/

xlsclients -l 找出的window id是_NET_WM_USER_TIME_WINDOW(WINDOW): window id # 0x8600084
WM_CLIENT_LEADER(WINDOW): window id # 0x8600001
一般是leader window id, 但实际上我们需要的是显示窗口的id， 就是佣xwininfo得到的显示的window id window id # 0x8600084。

得到当前active window的id可以用
xprop -root '_NET_ACTIVE_WINDOW'

zxx@gll-bac:/usr/share/man$ xprop -root '_NET_ACTIVE_WINDOW'
_NET_ACTIVE_WINDOW(WINDOW): window id # 0x8600083
zxx@gll-bac:/usr/share/man$ xprop -id 0x8600083


./gw id > wlist 
for i in `cat wlist`; do echo $i; xwininfo -id "$i" |grep IsView ; done

for i in `cat wlist`; do  xwininfo -id "$i" |grep IsView ;if [ $? -eq 0 ]; then  result=$i; fi; done

for i in `cat wlist`; do  xwininfo -id "$i" |grep -q "IsViewable" ;if [ $? -eq 0 ]; then  echo $i > result; fi; done
xdottool windowunmap 'id'
        
wmctrl
xprop 
xwininfo
xlsclient

这四条命令都可以得到窗口id，但是取得的都不同。
xlsclient 列出的是leader window，
实际需要的可以是xwininfo 用鼠标点中的和wmctrl -l 列出的。

2.program
http://stackoverflow.com/questions/151407/how-to-get-an-x11-window-from-a-process-id

 // Attempt to identify a window by name or attribute.
// by Adam Pierce <adam@doctort.org>

#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <iostream>
#include <list>

using namespace std;

class WindowsMatchingPid
{
public:
    WindowsMatchingPid(Display *display, Window wRoot, unsigned long pid)
    	: _display(display)
    	, _pid(pid)
    {
    // Get the PID property atom.
    	_atomPID = XInternAtom(display, "_NET_WM_PID", True);
    	if(_atomPID == None)
    	{
    		cout << "No such atom" << endl;
    		return;
    	}

    	search(wRoot);
    }

    const list<Window> &result() const { return _result; }

private:
    unsigned long  _pid;
    Atom           _atomPID;
    Display       *_display;
    list<Window>   _result;

    void search(Window w)
    {
    // Get the PID for the current Window.
    	Atom           type;
    	int            format;
    	unsigned long  nItems;
    	unsigned long  bytesAfter;
    	unsigned char *propPID = 0;
    	if(Success == XGetWindowProperty(_display, w, _atomPID, 0, 1, False, XA_CARDINAL,
    	                                 &type, &format, &nItems, &bytesAfter, &propPID))
    	{
    		if(propPID != 0)
    		{
    		// If the PID matches, add this window to the result set.
    			if(_pid == *((unsigned long *)propPID))
    				_result.push_back(w);

    			XFree(propPID);
    		}
    	}

    // Recurse into child windows.
    	Window    wRoot;
    	Window    wParent;
    	Window   *wChild;
    	unsigned  nChildren;
    	if(0 != XQueryTree(_display, w, &wRoot, &wParent, &wChild, &nChildren))
    	{
    		for(unsigned i = 0; i < nChildren; i++)
    			search(wChild[i]);
    	}
    }
};

int main(int argc, char **argv)
{
    if(argc < 2)
    	return 1;

    int pid = atoi(argv[1]);
    cout << "Searching for windows associated with PID " << pid << endl;

// Start with the root window.
    Display *display = XOpenDisplay(0);

    WindowsMatchingPid match(display, XDefaultRootWindow(display), pid);

// Print the result.
    const list<Window> &result = match.result();
    for(list<Window>::const_iterator it = result.begin(); it != result.end(); it++)
    	cout << "Window #" << (unsigned long)(*it) << endl;

    return 0;
}

===========================
  在 unix 系统中，不同的应用程式要共享或交换资料，可以透过像
      pipe，share memory 等内部程序沟通(InterProcess Communication)
      的机制来达成；而在 X 视窗系统中，也提供了类似 unix 内部程序沟
      通的机制，使得不同 X 视窗的应用程式可以共享或交换资料，这机制
      就是 X 视窗系统中的性质(property)。打个比方来说，我们可以把 X
      视窗的性质看做是一个可以装填资料的容器，这个容器标明了一个名字
      与其内含值的资料型态，并且将这个容器放在相关应用程式都知道的
      地方，於是这些相关的应用程式就可透过这个容器，来达成资料共享或
      资料交换的目的。本文即就 X 视窗的性质机制作一番研讨，并设计两支
      X 视窗的应用程式，来验证透过性质的机制可使不同的应用程式共享资料。
       
       
      性质与原子
       
      在导言中提到过，性质必须有名字(name)及内含值的资料型态(data type)
      ，这两者都是以可变长度的字元串来定义的，例如定义一个性质的名字
      (name)为「bdc」，其资料型态(data type)为「bdc_type」。应用程式
      可以自行定义性质的名字与内含值的资料型态，然後再分别将它们转换
      为原子，也可以使用 X 视窗预先为我们定义好的性质名字的原子与资料
      型态的原子，<X11/Xatom.h> 标头档中就包含了这些定义好的原子，
      其起始字元串皆为「XA_」，如 XA_STRING，XA_INTEGER 等。而什麽
      是原子呢？我们已经知道性质的名字与内含值的资料型态是以可变长度
      的字元串来定义的，但是在 X 伺服器与应用程式之间，藉由传送整个
      字元串来指定性质的名字与内含值的资料型态是没有效率且浪费网路
      频宽的；因此，X 视窗系统以另一个三十二位元的识别码(32-bit id)
      来表示这个字元串，这三十二位元的识别码就是「原子」(atom)。在
      同一个 X 伺服器上，每一个原子都是唯一的(unique)，不会有两个
      原子是相同的。
       
       
      为性质命名
       
      应用程式可以使用 X 视窗预先定义的性质名字的原子，如果应用程式
      不打算使用预先定义的性质名字的原子，可以自行定义性质的名字，
      然後将它转换为原子。当应用程式为一个性质取定一个名字後，接著
      便是将这个名字转换为 X 伺服器看得懂的原子，转换的工作可藉由呼叫
       XInternAtom 来达成，其函式的型式如下：
       
           Display *display;
           char    property_name[];
           Bool    only_if_exists;
           Atom    atom;
       
           atom = XInternAtom(display, property_name, only_if_exists);
       
           display 为应用程式和 X 伺服器的连线(connection)，通常 X 视窗的
           应用程式一开始就会建立这条连线。
           property_name 为性质的名字，当应用程式要产生一个新的性质时，
           指定 False 给 only_if_exists；当性质已经存在且已悬挂在某视窗上，
           则指定 True 给 only_if_exists，此时 XInternAtom 会传回该性质名字
           相对应的原子；但是如果此性质已经不存在，而应用程式又指明 only_if_exists
           之值为 True，此时 XInternAtom 的传回值为 None。在为性质命名时，必须
           注意名字的大小写是有分别的，如「thing」和「Thing」，分别代表两个不同
           性质的名字。
       
           如果 XInternAtom 在执行中发生错误，则其传籺ernAtom
      以产生一个新的性质，其转换出来的原子叫做 myproperty。toplevel widget 有两个
      孩子及两个孙子，分别是 rc 、 quit_btn 、 data_field 及 put_data，其中
      data_field 及 put_data 都是 rc 的孩子。 put_data widget 有一个事件处理程序
       (event handler) 叫做 PutData，其主要工作是当 put_data widget 被压下时，呼叫
      XmTextGetString 函式将 text widget 中的资料存放到一个缓冲区後，再呼叫
      XChangeProperty 函式将缓冲区内的资料存放到根视窗的性质中。 quit_btn widget
      有一个回叫程序 (callback procedure) 叫做 delete_prop，其主要工作是呼叫 XDeleteProperty
      函式删除该性质的定义，之後呼叫 XtCloseDispaly 函式把应用程式和 X 伺服器的连线
      结束掉。
       
       
      【 get_from_prop.c 】
       
      此程式的主要大纲为：在事件回圈(event loop)中侦收 PropertyNotify 事件，当
      PropertyNotify 事件发生时，判断其发生事件的视窗是否为根视窗及性质名字的
      原子是否为应用程式所感兴趣的原子；如果是，则呼叫 GetData 程序将性质内的资
      料读取出来，显示在 text widget 上；如果其中一个条件不符，则呼叫 XtDispatchEvent
      函式将事件丢往它该去的视窗上。程式一开始执行 X 视窗应用程式的初始化工作，以
      产生一个 toplevel widget，接著分别呼叫 XtDisplay 及 DefaultRootWindow
      以取得应用程式和 X 伺服器的连线及根视窗的视窗识别码，这两个都是呼叫性质操作
      函式时会用到的参数；再来则是抓取命令列的第二个参数作为性质的名字，指定 True 给
      only_if_exists 後，呼叫 XInternAtom 找出其相对应的原子，如果此性质不存在，则
      传回 None。 toplevel widget 有两个孩子及一个孙子，分别是 rc 、 quit_bnt 及
      data_field，其中 data_field 为 rc 的孩子。因为性质是悬挂在根视窗下，而根视窗
      并不是一个 widget，所以无法使用 XtMainLoop 及 XtAddEventHandler 的函式呼叫来
      对 PropertyNotify 事件做出反应，因此应用程式改采 Xlib 的风格来选择事件及设计
      事件回圈。GetData 程序中呼叫了 XGetWindowProperty 函式，从根视窗的性质中去读
      取资料，其参数 offset 及 length 分别为 0 及 8192，这是一般性质所能存放资料的
      最大空间；参数 delete 之值为 False，表示应用程式在读取完性质内的资料後，不去
      删除该性质的定义；应用程式所期望的性质资料型态为 XA_STRING ，这是 X 视窗预先
      定义(predefined)的性质资料型态的原子，而此函式後面的五个参数皆为结果回传值，
      执行完此函式後，应用程式判断其是否执行成功及性质内的真正资料型态是否和应用程式
      所期望资料型态的一致，如果两项条件皆符合，接著便呼叫 XmTextSetString 函式将回传回来的
      资料显示於 text widget 中，最後呼叫 XFree 函式把 X 视窗系统为应用程式配置的
      缓冲空间(ret_property)释放掉。
       
       
      程式执行画面说明
       
      图一：在背景下分别执行 put_to_prop 及 get_from_prop 两支程式，性质的名字为
            「behavior」(put_to_prop behavior&;sleep 5;get_from_prop behavior&)，
            待视窗出现後在 put_to_prop 的 text widget 中键入资料，此时尚未压下
            PutData widget，所以 put_to_prop 的 text widget 中的资料还未存放到
            根视窗的 behavior 性质中。
      图二：压下在 put_to_prop 中的 PutData widget，此时 put_to_prop 的 text widget
            中的资料被存放到悬挂在根视窗的 behavior 性质内，同此时刻 get_from_prop
            侦收到 ProertyNotify 事件，接著就到根视窗的 behavior 性质中去读取资料，
            并将资料显示於 get_from_prop 的 text widget 中。
       
       
       
       
      /*
       *  Program: put_to_prop.c
       *
       *  Purpose: Retrieve data from text widget, then put it into
       *           a specified property which is hanged on root window.
       *
       *  Author : Chung-Chia Chen
       *
       *  Date   : Dec. 14, 1994
       */
       
      #include <X11/StringDefs.h>
      #include <X11/Intrinsic.h>
      #include <X11/Xatom.h>
      #include <Xm/Xm.h>
      #include <Xm/RowColumn.h>
      #include <Xm/PushB.h>
      #include <Xm/Text.h>
      #include <stdio.h>
      #include <stdlib.h>
       
      #define ROWS 10
      #define COLS 40
       
      static void PutData(Widget, Widget*, XEvent*);
      static void DeleteProp(Widget, caddr_t, XmAnyCallbackStruct*);
       
      static Display   *mydisplay;
      static Window    root_window;
      static Atom      myproperty;
       
      void main(int argc, char *argv[])
      {
        Widget      toplevel, rc, put_data, data_field, quit_btn;
       
        if( argv[1] == NULL) {
            printf("Usage: program_name property_name\n");
            exit(0);
        }
       
        toplevel = XtInitialize(argv[0], "PutDemo", NULL, 0,
                                &argc, argv);
       
        mydisplay = XtDisplay(toplevel);
       
        if( (root_window = DefaultRootWindow(mydisplay)) == NULL ) {
             printf("root_window id is null\n");
             exit(-1);
        }
        /***************************************************
         * Get the display and root window id.
         ***************************************************/
       
        myproperty = XInternAtom(mydisplay, argv[1], False);
        if( myproperty == None ) {
            printf("Trying to create argv[1] property failed.", argv[1]);
            exit(-1);
        }
        /**********************************************************
         * Create a new property, convert the property's name
         * into an atom called myproperty.
         * Application takes predefined atom "XA_STRING" as the
         * data type of the property, so the job that converts
         * the property's data type into an atom can be exempted.
         **********************************************************/
       
        rc = XtVaCreateManagedWidget("Panel",
                              xmRowColumnWidgetClass,         toplevel,
                              NULL);
       
        data_field = XtVaCreateManagedWidget("DataField",
                                      xmTextWidgetClass,      rc,
                                      XmNeditMode,    XmMULTI_LINE_EDIT,
                                      XmNrows,        ROWS,
                                      XmNcolumns,     COLS,
                                      NULL);
       
        put_data = XtVaCreateManagedWidget("PutData",
                                    xmPushButtonWidgetClass, rc,
                                    NULL);
       
        XtAddEventHandler(put_data, ButtonPressMask, FALSE ,
                          (XtEventHandler) PutData, &data_field);
        /********************************************************
         * Create a push button widget(put_data), then register
         * an event handler named PutData which solicits button
         * press event.
         * data_field is taken as a client data which is gonna
         * pass to the PutData event handler.
         ********************************************************/
       
        quit_btn = XtVaCreateManagedWidget("Quit",
                             xmPushButtonWidgetClass, rc,
                             NULL);
       
        XtAddCallback(quit_btn, XmNactivateCallback,
                      (XtCallbackProc) DeleteProp, NULL);
       
        XtRealizeWidget(toplevel);
       
        XtMainLoop();
       
      }
       
      static void PutData(Widget w,
                          Widget *client_data,
                          XEvent *ev)
      {
           char *buff;
       
           buff = XmTextGetString(*client_data);
           if(buff == NULL) {
              printf("XmTextGetString returns NULL\n");
              return;
           }
       
           XChangeProperty(mydisplay, root_window,
                           myproperty, XA_STRING,
                           32, PropModeReplace,
                           (unsigned char*) buff, strlen(buff)); 





3.x window property table
http://standards.freedesktop.org/wm-spec/latest/ar01s05.html



4. x server
The graphic interface in linux is provided by x server, server will provide all the resources,
including window, paint.....
since x server is a server so it has the number to specify it,
hostanme:displaynum:screenum
Normally, in one host which has only one screennum, the part matters is displaynum
displaynum specify which server it is
if hostname is not localhost, then 
the X server is listen on the port :600n
n is the displaynum when you log in
echo $DISPLAY
:1
in the localhost, local program connect x server using unix stream such as
unix 3 []  STREAM CONNECTED 355580   /tmp/.X11-unix/X4
if the connection is from other host, then tcp connection used
*****************
in 140 host, echo $DISPLAY
:1
then in host 202, 
export DISPLAY=10.121.122.140:0
gedit
then the prg gedit window will pop on the 140 host.
--------------------------------
in 140 host
nestat -anpt |grep 60
tcp 0  0  ::::6001   :::*   LISTEN 
when connection established 
tcp 0 0 10.121.122.140:6001    10.121.122.202:50862    ESTBLISHED

So sometimes, fail to connect to X server, be refused,
mostly because the access control of X server, using xhost + to allow all hosts could access
the X server, in such case, you need to run xhost + in the 140 host to make 202 is accessible
to it .

5. connect x server via ssh
using ssh -Y snail@10.121.122.140  in 202 host
then the display number will be assigned automatically
All true data transfer between the two hosts is via ssh connection
while the x server message will be transport in ssh connection
and two hosts will use two localhost tcp connection to transfer x server message
-------------------------------
snail@gemu ~ $ echo $DISPLAY
:10 
snail@gemu ~ $ netstat -atpn |grep 6010
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      -
tcp        0      0 127.0.0.1:49703         127.0.0.1:6010          ESTABLISHED 26805/gedit
tcp        0      0 127.0.0.1:6010          127.0.0.1:49703         ESTABLISHED -
tcp6       0      0 ::1:6010                :::*                    LISTEN      -
-----------------------------------
the real data transfer in ssh connection,
and the x server message is extracted from ssh connection data,and forward to port localhost
when type gedit in 202 host, 49703 is the forward port, it will connected to 6010.
in fact the x server will be opened when ssh -Y successfully, it will listen on the port.
when gedit is type, the connection is established
-------------
snail@gemu ~ $ netstat -atpn |grep 202
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp        0      0 10.121.122.140:22       10.121.122.202:56635    ESTABLISHED -
---------------
[guolili@cougar src]$ echo $DISPLAY
localhost:6 
[guolili@cougar src]$ netstat -apn|grep X6
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
unix  2      [ ACC ]     STREAM     LISTENING     3732122 16392/Xvnc          /tmp/.X11-unix/X6
unix  3      [ ]         STREAM     CONNECTED     7105044 16392/Xvnc          /tmp/.X11-unix/X6
-----------------
in the cougar before ssh -Y into gemu, the diplaynumber is 6, so wehn ssh into gemu, run gedit
the gedit window will pop on the cougar number 6 x server
when gedit is called, there will be an extara CONNECTED unix stream in the cougar(202)
***************************
So sometimes, fail to connect to X server, be refused,
mostly because the access control of X server, using xhost + to allow all hosts could access
the X server, but in ssh -Y case, it's not that case, cause it's client is itself localhost.


**  x window server access permission


* gtk编程
GTK编程  （ubuntu） (2009-12-06 16:59:31)转载
标签： it	分类： Linux
** 配置gcc
刚装好的系统中已经有GCC了，但是这个GCC什么文件都不能编译，因为没有一些必须的头文件，所以要安装build-essential这个软件包，安装了这个包会自动安装上g ,libc6-dev,linux-libc-dev,libstdc 6-4.1-dev等一些必须的软件和头文件的库。
可以在新立得里面搜索build-essential或输入下面命令：
sudo apt-get install build-essential
安装完成后写一个C语言程序testc.c测试一下。
int main()
{
printf("Hello Ubuntu!\n");
return 0;
}
$ gcc testc.c -o testc
$ ./testc
Hello Ubuntu!
** gtk的安装
sudo apt-get install vim #使用vim来编写代码，当然您可以使用任何自己喜欢的编辑器
sudo apt-get install build-essential #这将安装gcc/g /gdb/make 等基本编程工具
sudo apt-get install gnome-core-devel #这将安装 libgtk2.0-dev libglib2.0-dev 等开发相关的库文件
sudo apt-get install pkg-config #用于在编译GTK程序时自动找出头文件及库文件位置
sudo apt-get install devhelp #这将安装 devhelp GTK文档查看程序
sudo apt-get install libglib2.0-doc libgtk2.0-doc #这将安装 gtk/glib 的API参考手册及其它帮助文档
sudo apt-get instal glade libglade2-dev #这将安装基于GTK的界面构造程序。
** 测试程序
#include<gtk/gtk.h>
void hello(GtkWidget *widget,gpointer data)
{
g_print("Hello Ubuntu!\n");
}
gint delete_event(GtkWidget *widget,GdkEvent *event,gpointer data)
{
g_print ("delete event occurred\n");
return(TRUE);
}
void destroy(GtkWidget *widget,gpointer data)
{
gtk_main_quit();
}
int main( int argc, char *argv[] )
{
GtkWidget *window;
GtkWidget *button;
gtk_init (&argc, &argv);
window=gtk_window_new (GTK_WINDOW_TOPLEVEL);
gtk_signal_connect (GTK_OBJECT(window),"delete_event",GTK_SIGNAL_FUNC(delete_event),NULL);
gtk_signal_connect (GTK_OBJECT (window), "destroy",GTK_SIGNAL_FUNC (destroy), NULL);
gtk_container_set_border_width (GTK_CONTAINER (window), 10);
button = gtk_button_new_with_label ("Hello Ubuntu!");
gtk_signal_connect (GTK_OBJECT (button), "clicked",GTK_SIGNAL_FUNC (hello), NULL);
gtk_signal_connect_object (GTK_OBJECT (button), "clicked",GTK_SIGNAL_FUNC (gtk_widget_destroy),GTK_OBJECT (window));
gtk_container_add (GTK_CONTAINER (window), button);
gtk_widget_show (button);
gtk_widget_show (window);
gtk_main();
return(0);
}
用下面命令编译运行
$ gcc gtkhello.c -o gtktest `pkg-config --cflags --libs gtk+-2.0`
$ ./gtktest
会显示一个带有一个按钮的窗口，点击按钮以后窗口关闭，命令行显示Hello Ubuntu


* gtk enviroment


sudo apt-get install gnome-core-devel
sudo apt-get install libglib2.0-doc libgtk2.0-doc
sudo apt-get install devhelp
sudo apt-get install glade-gnome glade-common glade-doc 



* Android完全编译


http://blog.csdn.net/HKjinzhao/archive/2009/03/18/4002326.aspx

/**
版本：1.0
日期：2009-03-18
作者：HKjinzhao
备注：初始版本
*/
/**
版本：1.1
日期：2009-03-27
作者：HKjinzhao
备注：增加make sdk，修改一些内容
*/

本次编译过程主要参考官方文档（http://source.android.com/download）和网上相关资料（如http://blog.csdn.net/liaoshengjiong/archive/2009/03/04/3957749.aspx）

编译环境：Ubuntu8.10

1、安装一些环境
 sudo apt-get install build-essential
 sudo apt-get install make
 sudo apt-get install gcc
 sudo apt-get install g++
 sudo apt-get install libc6-dev
 
 sudo apt-get install patch
 sudo apt-get install texinfo
 sudo apt-get install libncurses-dev
 
 sudo apt-get install git-core gnupg
 sudo apt-get install flex bison gperf libsdl-dev libesd0-dev libwxgtk2.6-dev build-essential zip curl
 sudo apt-get install ncurses-dev
 sudo apt-get install zlib1g-dev
 sudo apt-get install valgrind
 sudo apt-get install python2.5

安装java环境
sudo apt-get install sun-java6-jre sun-java6-plugin sun-java6-fonts sun-java6-jdk

注：官方文档说如果用sun-java6-jdk可出问题，得要用sun-java5-jdk。经测试发现，如果仅仅make（make不包括make sdk），用sun-java6-jdk是没有问题的。而make sdk，就会有问题，严格来说是在make doc出问题，它需要的javadoc版本为1.5。
因此，我们安装完sun-java6-jdk后最好再安装sun-java5-jdk，或者只安装sun-java5-jdk。这里sun-java6-jdk和sun-java5-jdk都安装，并只修改javadoc.1.gz和 javadoc。因为只有这两个是make sdk用到的。这样的话，除了javadoc工具是用1.5版本，其它均用1.6版本：
sudo apt-get install sun-java5-jdk
修改javadoc的link
cd /etc/alternatives
sudo rm javadoc.1.gz
sudo ln -s /usr/lib/jvm/java-1.5.0-sun/man/man1/javadoc.1.gz javadoc.1.gz
sudo rm javadoc
sudo ln -s /usr/lib/jvm/java-1.5.0-sun/bin/javadoc javadoc

2、设置环境变量
vim ~/.bashrc
在.bashrc中新增或整合PATH变量，如下

#java 程序开发/运行的一些环境变量
JAVA_HOME=/usr/lib/jvm/java-6-sun
JRE_HOME=${JAVA_HOME}/jre
export ANDROID_JAVA_HOME=$JAVA_HOME
export CLASSPATH=.:${JAVA_HOME}/lib:$JRE_HOME/lib:$CLASSPATH
export JAVA_PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin
export JAVA_HOME;
export JRE_HOME;
export CLASSPATH;
HOME_BIN=~/bin/
export PATH=${PATH}:${JAVA_PATH}:${JRE_PATH}:${HOME_BIN};
#echo $PATH;

最后，同步这些变化：
source ~/.bashrc

3、安装repo（用来更新android源码）
创建~/bin目录，用来存放repo程序，如下：
$ cd ~
$ mkdir bin
并加到环境变量PATH中，在第2步中已经加入
下载repo脚本并使其可执行：
$ curl http://android.git.kernel.org/repo >~/bin/repo
$ chmod a+x ~/bin/repo

4、下载 android源码并更新之
建议不要用repo来下载（android源码超过1G，非常慢），直接在网上下载http://www.androidin.com/bbs/pub /cupcake.tar.gz。而且解压出来的 cupcake下也有.repo文件夹，可以通过repo sync来更新cupcake代码：
tar -xvf  cupcake.tar.gz

repo sync（更新很慢，用了3个小时）

5、编译android源码,并得到~/project/android/cupcake/out 目录
进入android源码目录：
make
这一过程很久（2个多小时）

6、在模拟器上运行编译好android

android SDK的emulator程序在android-sdk-linux_x86-1.0_r2/tools/下，emulator是需要加载一些image 的，默认加载android-sdk-linux_x86-1.0_r2/tools/lib/images下的kernel-qemu（内核） ramdisk.img  system.img  userdata.img

编译好android之后，emulator 在~/project/android/cupcake/out/host/linux-x86/bin下， ramdisk.img  system.img  userdata.img则在~/project/android/cupcake/out/target/product/generic下
cd ~/project/android/cupcake/out/host/linux-x86/bin

增加环境变量
vim ~/.bashrc
在.bashrc中新增环境变量，如下
#java 程序开发/运行的一些环境变量
export ANDROID_PRODUCT_OUT=~/project/android/cupcake2/out/target/product/generic
ANDROID_PRODUCT_OUT_BIN=~/project/android/cupcake2/out/host/linux-x86/bin
export PATH=${PATH}:${ANDROID_PRODUCT_OUT_BIN};

最后，同步这些变化：
source ~/.bashrc

emulator -image system.img -data userdata.img -ramdisk ramdisk.img
最后进入android桌面，就说明成功了。
out/host/linux-x86/bin下生成许多有用工具（包括android SDK/tools的所有工具），因此，可以把eclipse中android SDK的路径指定到out/host/linux-x86/bin进行开发

7、编译linux kernel
直接make android源码时，并没有make linux kernel。因此是在运行模拟器，所以不用编译 linux kernel。如果要移值android，或增删驱动，则需要编译 linux kernel
linux kernel的编译将在以后的文章中介绍。

8、编译模块
android中的一个应用程序可以单独编译，编译后要重新生成system.img
在源码目录下执行
. build/envsetup.sh （.后面有空格）
就多出一些命令：
- croot:   Changes directory to the top of the tree.
- m:       Makes from the top of the tree.
- mm:      Builds all of the modules in the current directory.
- mmm:     Builds all of the modules in the supplied directories.
- cgrep:   Greps on all local C/C++ files.
- jgrep:   Greps on all local Java files.
- resgrep: Greps on all local res/*.xml files.
- godir:   Go to the directory containing a file.
可以加—help查看用法
我们可以使用mmm来编译指定目录的模块，如编译联系人：
 mmm packages/apps/Contacts/
编完之后生成两个文件：
out/target/product/generic/data/app/ContactsTests.apk
out/target/product/generic/system/app/ Contacts.apk
可以使用make snod重新生成system.img
再运行模拟器

9、编译SDK
直接执行make是不包括make sdk的。make sdk用来生成SDK，这样，我们就可以用与源码同步的SDK来开发 android了。

1）修改/frameworks/base/include/utils/Asset.h
‘UNCOMPRESS_DATA_MAX = 1 * 1024 * 1024’ 改为 ‘UNCOMPRESS_DATA_MAX = 2 * 1024 * 1024’
原因是Eclipse编译工程需要大于1.3M的buffer

2）编译ADT。
注意，我们是先执行2），再执行3）。因为在执行./build_server.sh时，会把生成的SDK清除了。
用上了新的源码，adt这个调试工具也得自己来生成，步骤如下：
进入cupcake源码的development/tools/eclipse/scripts目录，执行：
export ECLIPSE_HOME=你的eclipse路径
./build_server.sh 你想放ADT的路径

3）执行make sdk。
注意，这里需要的javadoc版本为1.5，所以你需要在步骤1中同时安装sun-java5-jdk
make sdk
编译很慢。编译后生成的SDK存放在out/host/linux-x86/sdk/，此目录下有android-sdk_eng.xxx_linux- x86.zip和android-sdk_eng.xxx_linux-x86目录。android-sdk_eng.xxx_linux-x86就是 SDK目录
实际上，当用mmm命令编译模块时，一样会把SDK的输出文件清除，因此，最好把android-sdk_eng.xxx_linux-x86移出来

4）关于环境变量、android工具的选择
目前的android工具有：
A、我们从网上下载的SDK（ tools下有许多android工具，lib/images下有img映像）
B、我们用make sdk编译出来的SDK（ tools下也有许多android工具，lib/images下有img映像）
C、我们用make编译出来的out目录（ tools下也有许多android工具，lib/images下有img映像）
那么我们应该用那些工具和img呢？
首先，我们不会用A选项的工具和img，因为一般来说它比较旧，也源码不同步。测试发现，如果使用B选项的工具和img，android模拟器窗口变小（可能是skin加载不了），而用C选项的工具和img则不会有此问题。
有些android工具依赖android.jar（比如android），因此，我们在eclipse中使用B选项的工具（SDK），使用C选项的 img。其实，从emulator -help-build-images也可以看出，ANDROID_PRODUCT_OUT是指向C选项的img目录的
不过，除了用A选项的工具和img，用B或C的模拟器都不能加载sdcard，原因还不清楚。

5）安装、配置ADT
安装、配置ADT请参考官方文档

6）创建Android Virtual Device
编译出来的SDK是没有AVD（Android Virtual Device）的，我们可以通过android工具查看：
android list
输出为：
Available Android targets:
[1] Android 1.5
     API level: 3
     Skins: HVGA-P, QVGA-L, HVGA-L, HVGA (default), QVGA-P
Available Android Virtual Devices:
表明没有AVD。如果没有AVD，eclipse编译工程时会出错（Failed to find a AVD compatible with target 'Android 1.5'. Launch aborted.）
创建AVD：
android create avd -t 1 -c ~/sdcard.img -n myavd
可以android –help来查看上面命令选项的用法。创建中有一些选项，默认就行了
再执行android list，可以看到AVD存放的位置
以后每次运行emulator都要加-avd myavd或@myavd选项，这里eclipse才会在你打开的emulator中调试程序


注意：
这样，SDK和ADT就生成了，就按照官方文档把他们整合到Eclipse，这里不再细说了。
建个android的新工程，试试你自己编译的sdk。


* Android Building System 分析

http://www.codemud.net/~thinker/GinGin_CGI.py/show_id_doc/393
Android Building System 分析
by thinker
2 Columns
關鍵字:
Android coding
想要了解一個系統，我常會從 makefile 或是 building system 下手，以了解系統組成元素為何? 目錄結構為何? 對於 Android ，我也不例外。透過了解 building system ，我們能知道如何新增、修改、刪除程式，並保有完整性，順利編譯出結果。

設定檔

Android building system 包括幾種重要的設定檔，

    * Android.mk
    * AndroidProducts.mk
    * target_<os>-<arch>.mk, host_<os>-<arch>.mk and <os>-<arch>.mk
    * BoardConfig.mk
    * buildspec.mk 

Android.mk 是 module 和 package 的設定檔，每個 module/package 的目錄下都會有一個 Android.mk。所謂的 module 是指系統的 native code ，相對於用 Java 寫成的 Android application 稱為 package。

AndroidProducts.mk 則設定 product 配置。 product 即特定系統版本，透過編譯不同 product ，產生不同軟體配置內容，安裝不同的 application。 Product 可視為特定專案，產生特定規格系統。

BoardConfig.mk 是為 product 主板做設定，像是 driver 選擇、設定。*<os>-<arch>.mk 則是針對選擇的作業系統和 CPU 架構，進行相關設定。

buildspec.mk 是位於 source 根目錄下，為進行編譯者所做之額外設定。例如，可在此選擇要產生的 product 、平台、額外的 module/package 等。

參數

build/envsetup.sh 實作一個 mm 指令，以編譯單一 module，不需編譯整個 source tree。ONE_SHOT_MAKEFILE 這個 makefile 變數/參數就是用以實作這個功能。使用方法是在執行 make 時，將該變數指定為 module 的 Android.mk。

    * make ONE_SHOT_MAKEFILE=<path to Androiod.mk> 

透過定義 CREATE_MODULE_INFO_FILE ， building system 會將所有 module 資訊列在 $(PRODUCT_OUT)/module-info.txt 檔案裡。

    * make CREATE_MODULE_INFO_FILE=true 

設定 BUILD_TINY_ANDROID=true ， building system 產生一個簡單的 image ，以測試硬體的可用度。此功能用於移植的早期階段，以快速 bring up 。

HOST_BUILD_TYPE 和 TARGET_BUILD_TYPE 指定 building system 產生 binary 的目的為 debug 或 release 。透過設定此二變數，能產生包含 debug information 的 binry 。

    * debug
    * release 

這些參數，也可設於 buildspec.mk 裡，以避免開發過程不斷的重新指定。

Goals

一般編輯整個 Android 系統，就是使用 droid 這個 goal。 droid 會產生一個完整的系統，包括 bootloader、kernel、系統程式、模組和應用程式。

showcommands 和 droid 功能相同，但 droid 在編譯過程不顯示所使用的指令。透過 showcommands 這個 goal， building system 顯示過程中每一個步驟的詳細指令。

Makefile 的流程

    * 初始化相關變數
    * 偵測編譯環境和目標環境
    * 決定目標 product
    * 讀取 product 的設定
    * 讀取 product 所指定之目標平台架構設定
          o 選擇 toolchain
          o 指定編譯參數 (*<os>-<arch>.mk) 
    * 清除輸出目錄
    * 設定/檢查版本編號
    * 讀取所有 BoardConfig.mk 檔案
    * 讀取所有 module 的設定
    * 根據設定，產生必需的 rule
    * 產生 image 

以上的主要流程都是由 build/core/main.mk 所安排。

初始化和偵測

由 build/core/config.mk 所進行。 build/core/envsetup.mk 檢查 developer 的設定 (buildspec.mk) ，並檢查執行環境，以決定輸出目錄、項目。

build/core/config.mk 本身還依據參數，決定解譯時的相關參數。像是 compiler 的路徑、flags， lex 、yacc 的路徑參數等。

關於 product 的相關設定，則是由 build/core/product_config.mk 所處理，使用 build/core/product.mk 提供之 macro 載入。根據 AndroidProduct.mk 的內容， product_config.mk 決定了

    * PRODUCT_TAGS
    * OTA_PUBLIC_KEYS
    * PRODUCT_POLICY
    * ...... 

Product 設定的讀取

Android product 的設定來自於 build/target/product/AndroidProduct.mk 和 vendor 子目錄下的 AndroidProduct.mk 。 building system 透過 find 指令，找出所有可能的 AndroidProduct.mk。 AndroidProduct.mk 裡定義 PRODUCT_MAKEFILES 變數，列舉所有實際定義 product 的 makefile。這些 makefile 各自定義獨立的 product 。product 相關參數，存成 PRODUCTS.<path of makefile>.<variable> 形式的變數。並將 makefile 路徑存在 PRODUCTS 變數。因此，透過 PRODUCTS 能取得所有的 product 路徑/名稱，並透過 PRODUCTS.<path of makefile>.<variable> 形式的變數取得內容。

Module 設定的讀取

Module 是指 native code 的軟體元件，而 Java application 則被稱為 package。 build/core/definitions.mk 定義 module/package 相關 macro ，讀取、檢查 module/package 定義檔；分散 source tree 各處的 Android.mk 檔案。 build/core/main.mk 使用 find 指令，在這些子目錄下找出所有 Android.mk ，並將路徑存在 subdir_makefiles 變數裡。最後，include 這些檔案。

這些 Android.mk 會 include 定義成變數 BUILD_SHARED_LIBRARY 、BUILD_PACKAGE 等，和其目的相配的 makefile。這些 makefile 會變 Android.mk 定義之內容，存成 ALL_MODULES.<path of Android.mk>.<variable> 形式。例如， Android.mk 定義了 LOCAL_MODULE_SUFFIX ，變會存成 ALL_MODULES.<path of Android.mk>.LOCAL_MODULE_SUFFIX 。而 Android.mk 路徑，當樣會存於 ALL_MODULES 變數裡。

Search Android.mk 的路徑，基本上會是整個 source tree 。但會依特定的 goal ，選擇性只找尋特定目錄。例如 SDK 只需特定目錄下的 Android.mk 。

Board Level 設定

和目標平台主板相關之設定，例如使用了什麼裝置、driver 等，或是是否需要編譯 bootloader 、 kernel 等，都是在 BoardConfig.mk 裡設定。同樣，每張主板可以有不同設定，存在不同目錄下的 BoardConfig.mk ，以 find 尋找如下檔案:

    * build/target/board/$(TARGET_DEVICE)/BoardConfig.mk
    * vendor/*/$(TARGET_DEVICE)/BoardConfig.mk 

TARGET_DEVICE 是 product 所定義，因此同一個 BoardConfig.mk 可被多個 product 所使用。一個 TARGET_DEVICE ，通常只有一個 BoardConfig.mk 。 BoardConfig.mk 會被直接 include 到 building system 的 name space 裡。因此，一些 module 的 enable/disable ，可以在 BoardConfig.mk 以對映不同的主板。

Rules

在 module 的定義檔 Android.mk 裡，可定義 module 的 tag， LOCAL_MODULE_TAGS，以分類這些 module。每一個 product 可以指定需要的 tag (PRODUCT_TAGS)，使 building system 只編譯標示這些 tag 的 module。在 build/core/main.mk 裡，所有標示特定 tag 的 module 收集為 ALL_DEFAULT_INSTALLED_MODULES ，並 include build/core/Makefile 處理。

build/core/Makefile 為這些 module 產生 rule ，並使產生 image 的 goal depend on 這些 rule ，使這些 module 被編譯。

結論

Android 的 building system 其實不是那麼複雜。在了解之後，也不是那麼難修改。但， GNU make 的一些語法，所 building system 使用一些不是那麼直覺的用法，使的 building system 較難了解。但，花點心思就能克服。 

* Android编译系统分析和使用

自带帮助文件
file:///home/zxx/Android-2.2/build/core/build-system.html
http://mmmyddd.freeshell.net/wiki/android/build.html


android-1.5最顶层的目录结构如下：
.
|-- Makefile        （全局的Makefile）
|-- bionic          （Bionic含义为仿生，这里面是一些基础的库的源代码）
|-- bootloader      （引导加载器）
|-- build           （build目录中的内容不是目标所用的代码，而是编译和配置所需要的脚本和工具）
|-- dalvik          （JAVA虚拟机）
|-- development     （程序开发所需要的模板和工具）
|-- external        （目标机器使用的一些库）
|-- frameworks      （应用程序的框架层）
|-- hardware        （与硬件相关的库）
|-- kernel          （Linux2.6的源代码）
|-- packages        （Android的各种应用程序）
|-- prebuilt        （Android在各种平台下编译的预置脚本）
|-- recovery        （与目标的恢复功能相关）
`-- system          （Android的底层的一些库）
黄色的好像没下到

Makefile 的分析：
在源代码根目录下的Makefile
include build/core/main.mk
                   |
include build/core/config.mk


make环境的分析：
build/envsetup.sh
这是一个需要source的shell文件，在命令行里应该是
source build/envsetup.sh
.   build/envsetup.sh
这两条命令是相同的。
但是
./build/envsetup.sh
sh ./build/envsetup.sh
又不同.
区别在于  source的文件后，所有function都可以当作命令输入其中，而后者只是shell执行的则不可以。

showcommands 
显示命令的执行， 一般命令前家@就会不显示此条命令。
如果把@变为可控的，就可以控制是否输出：
main.mk
--------------------------------------------
.PHONY: showcommands
showcommands:
	@echo >/dev/null
--------------------------------

definitions.mk
--------------------------------------------------------------------
###########################################################
## Output the command lines, or not
###########################################################

ifeq ($(strip $(SHOW_COMMANDS)),)
define pretty
@echo $1
endef
3~
hide := @
else
define pretty
endef
hide :=
endif
------------------------------------------------------------------------
$(hide) $(ACP) -fp $(CTS_HOST_JAR) $(PRIVATE_DIR)/tools
使用时hide放在命令行前就可以控制此条命令的执行时是否显示
所以用make showcommands编译就可以显示命令了。


MAKECMDGOALS
这是makefile默认的内置变量
The MAKECMDGOALS variable contains a list of all the targets specified on the command line for the current execution of make. It does not include command-line options or variable assignments. For instance:

$ make -f- FOO=bar -k goal <<< 'goal:;# $(MAKECMDGOALS)'
相当于
-----------------------------------------
goal:
	# $(MAKECMDGOALS)
------------------------------
# goal
参数 -f -k, 赋值 FOO=bar are not included in MAKECMDGOALS

The example uses the "trick" of telling make to read the makefile from the stdin with the -f- (or —file) option. The stdin is redirected from a command-line string using bash's here string, "<<<", syntax.[3] The makefile itself consists of the default goal goal, while the command script is given on the same line by separating the target from the command with a semicolon. The command script contains the single line:

    [3] For those of you who want to run this type of example in another shell, use:

# $(MAKECMDGOALS)


MAKECMDGOALS is typically used when a target requires special handling. The primary example is the "clean" target. When invoking "clean," make should not perform the usual dependency file generation triggered by include (discussed in Section 2.7 in Chapter 2). To prevent this use ifneq and MAKECMDGOALS:

ifneq "$(MAKECMDGOALS)" "clean"

  -include $(subst .xml,.d,$(xml_src))

endif


a single module to compile
main.mk
-----------------------------------------------------------------------------------------------------
ifneq ($(ONE_SHOT_MAKEFILE),)
# We've probably been invoked by the "mm" shell function
# with a subdirectory's makefile.
include $(ONE_SHOT_MAKEFILE)
# Change CUSTOM_MODULES to include only modules that were
# defined by this makefile; this will install all of those
# modules as a side-effect.  Do this after including ONE_SHOT_MAKEFILE
# so that the modules will be installed in the same place they
# would have been with a normal make.
CUSTOM_MODULES := $(sort $(call get-tagged-modules,$(ALL_MODULE_TAGS)))
FULL_BUILD :=
# Stub out the notice targets, which probably aren't defined
# when using ONE_SHOT_MAKEFILE.
NOTICE-HOST-%: ;
NOTICE-TARGET-%: ;

else # ONE_SHOT_MAKEFILE

#
# Include all of the makefiles in the system
#

# Can't use first-makefiles-under here because
# --mindepth=2 makes the prunes not work.
subdir_makefiles := \
	$(shell build/tools/findleaves.py --prune=out --prune=.repo --prune=.git $(subdirs) Android.mk)

include $(subdir_makefiles)
endif # ONE_SHOT_MAKEFILE
-----------------------------------------------------------------------------------------------------
这样可以在顶层 make <mymodulename> 来只编译一个单独的模块
make 時，將該變數指定為 module 的 Android.mk。

• make ONE_SHOT_MAKEFILE=<path to Androiod.mk> 


a default target in top level
if there's a buildspec.mk in top level, make will depend on this file,
---------
# Choose a variant to build.  If you don't pick one, the default is eng.
# User is what we ship.  Userdebug is that, with a few flags turned on
# for debugging.  Eng has lots of extra tools for development.
ifndef TARGET_BUILD_VARIANT
#TARGET_BUILD_VARIANT:=user
#TARGET_BUILD_VARIANT:=userdebug
#TARGET_BUILD_VARIANT:=eng
endif
--------------------------------------
if there's not buildspec.mk in top dir, then source envsetup.sh to set the build enviorment
envsetup.sh
-----------------------------------------
if [ "$selection" = "simulator" ]
    then
        export TARGET_PRODUCT=sim
        export TARGET_BUILD_VARIANT=eng
        export TARGET_SIMULATOR=true
        export TARGET_BUILD_TYPE=debug
-----------------------------------------------

编译的配置
--------------------------------------------------
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=2.2.1
TARGET_PRODUCT=generic
TARGET_BUILD_VARIANT=eng
TARGET_SIMULATOR=
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm
HOST_ARCH=x86
HOST_OS=linux
HOST_BUILD_TYPE=release
BUILD_ID=FRG83
------------------------------

parameter of make
./build/core/Makefile
# -----------------------------------------------------------------
# module info file
ifdef CREATE_MODULE_INFO_FILE
  MODULE_INFO_FILE := $(PRODUCT_OUT)/module-info.txt
  $(info Generating $(MODULE_INFO_FILE)...)
  $(shell rm -f $(MODULE_INFO_FILE))
  $(foreach m,$(ALL_MODULES), \
    $(shell echo "NAME=\"$(m)\"" \
	"PATH=\"$(strip $(ALL_MODULES.$(m).PATH))\"" \
	"TAGS=\"$(strip $(filter-out _%,$(ALL_MODULES.$(m).TAGS)))\"" \
	"BUILT=\"$(strip $(ALL_MODULES.$(m).BUILT))\"" \
	"INSTALLED=\"$(strip $(ALL_MODULES.$(m).INSTALLED))\"" >> $(MODULE_INFO_FILE)))
endif
--------------------------------------------------
make CREATE_MODULE_INFO_FILE=true

./build/core/main.mk
----------------------------------------------
else	# !SDK_ONLY
ifeq ($(BUILD_TINY_ANDROID), true)

# TINY_ANDROID is a super-minimal build configuration, handy for board 
# bringup and very low level debugging

subdirs := \
	bionic \
	system/core \
	build/libs \
	build/target \
	build/tools/acp \
	build/tools/apriori \
	build/tools/kcm \
	build/tools/soslim \
	external/elfcopy \
	external/elfutils \
	external/yaffs2 \
	external/zlib
---------------------------------------------------------------------------
make BUILD_TINY_ANDROID=true


make 時，將該變數指定為 module 的 Android.mk。

    * make ONE_SHOT_MAKEFILE=<path to Androiod.mk> 
*  Android 编译问题

代码下载 问题 ：
下载Google的Android操作系统的时候卡在下面一步：

 

 

我遇到的情况是 errno=connection refused

Getting repo ...
   from git://android.git.kernel.org/tools/repo.git
android.git.kernel.org[0: 204.152.191.45]: errno=Connection timed out
android.git.kernel.org[0: 130.239.17.12]: errno=Connection timed out
android.git.kernel.org[0: 149.20.20.141]: errno=Connection timed out
android.git.kernel.org[0: 199.6.1.176]: errno=Connection timed out
fatal: unable to connect a socket (Connection timed out)

找各种原因，可能是公司用的局域网ISP将Git的端口9418给封了，因为http://android.git.kernel.org是可以访问的。后来搜了一下知道很多git服务器同时提供端口80的下载。解决方法如下：

1.将命令行中的git://android.git.kernel.org换成http://android.git.kernel.org，

2.修改文件repo将里面的

REPO_URL='git://android.git.kernel.org/tools/repo.git' 改成

REPO_URL='http://android.git.kernel.org/tools/repo.git'

3. 修改文件.repo/manifests/default.xml将其中的 fetch="git://android.git.kernel.org/" 改成

fetch="http://android.git.kernel.org/"

这样就可以下载同步Android的源代码了
---------------------------------------------------------------------
步骤：

http://web.nchu.edu.tw/~jlu/cyut/android/build22.shtml

~/bin/repo init -u git://android.git.kernel.org/platform/manifest.git -b android-2.2.1_r1


（以下的步驟絕大部分都是在 Ubuntu/Linux 上執行）


   2. 在編譯 AOSP 原始碼之前，我們必須先安裝一些套件。這些步驟主要是參考 dferreira 發表的 [HOW-TO] Compile AOSP Froyo + [ROM] Latest AOSP Froyo for Sapphire。
         1. 在 /etc/apt/sources.list 檔案的最後加上下列兩行：

              deb http://pl.archive.ubuntu.com/ubuntu/ jaunty multiverse
              deb http://pl.archive.ubuntu.com/ubuntu/ jaunty universe
              

         2. 檔案修改完後，請執行下列指令來該新 apt 的資料庫：

              sudo apt-get update
              

         3. 請執行下列指令（只有一行）來安裝必要的軟體：

              sudo apt-get install git-core gnupg sun-java5-jdk flex bison gperf libsdl-dev libesd0-dev libwxgtk2.6-dev build-essential zip curl libncurses5-dev zlib1g-dev valgrind libreadline5-dev gcc-multilib g++-multilib libc6-dev libncurses5-dev x11proto-core-dev libx11-dev libreadline5-dev libz-dev
              

         4. 請在自己的家目錄（$HOME）底下新增一個 bin 目錄，並將 repo 安裝到 bin 內。安裝後可以登出然後登入，剛安裝的 repo 就可以開始使用。

              cd ~
              mkdir bin
              curl http://android.git.kernel.org/repo >~/bin/repo
              chmod a+x ~/bin/repo
              

         5. 決定 AOSP 原始碼放置的目錄，並建立該目錄。假設目錄的名稱是 froyo，且位於 $HOME，以下為執行並進入 froyo 目錄：

              mkdir ~/froyo
              cd ~/froyo
              

   3. 軟硬體的環境設定好了之後，我們就開始要從 AOSP 的網站把原始碼抓下來。
         1. 由於 Android 的版本眾多，你必須定義出究竟是哪一個版本是你要的。由於我們參考的 文件是編譯 Android 2.2 版的，因此我們的指令如下：

            repo init -u git://android.git.kernel.org/platform/manifest.git -b android-2.2.1_r1

            請特別注意以上指令的綠色部分：因為編譯的是 Android 2.2.1 版的，所以我們使用 android-2.2.1_r1，那麼如果有一天我要編譯 3.0 版呢？它的值應該是什麼呢？其實，這個資料可以從 http://android.git.kernel.org/ 的網頁上找尋 platform/manifest.git，然後在它之後的 summary 連結上點一下，就可以知道。在 http://android.git.kernel.org/?p=platform/manifest.git;a=summary 網頁的下方的 tags 部分就可以看到所有可能的值。

         2. 執行 repo sync 把定義好的原始碼抓回來，這個可能會等待比較久的時間。 

   4. 編譯 kernel 以及無線網路的驅動程式。就像在 把玩"魔術師" -- 編譯 AOSP 2.1 (Eclair) 原始碼 所說的，如果你能找到適當的 kernel 和 wlan.ko，那麼這個步驟可以省略。其實使用正確的 kernel 版本很重要，但是哪一版的 Android 應該配合哪一版的 kernel 呢？目前在網路上看到的情形是 "如果使用 Android x.x 版，但是 kernel 比較舊的 y.y 版，那麼一些新的功能是無法執行的"；所以從以上的圖片可以看出，HTC 的 kernel 是 2.6.27 版，而 Android 是 2.2，所以應該會有一些 2.2 的功能無法發揮。為了能夠編譯正確版本的 kernel，找到了 Wiki 上的 Android (operating system) 的列表，我把它整理如下：
          * Android 1.5 (Cupcake): Kernel 2.6.27
          * Android 1.6 (Donut): Kernel 2.6.29
          * Android 2.0/2.1 (Eclair): Kernel 2.6.29
          * Android 2.2 (Froyo): Kernel 2.6.32 

            作法一： 如果可能，請儘可能使用相同硬體，而且也已經編譯好的 kernel 和 wlan.ko。目前為止，總共有幾個現成的 kernel，分別是：
                o Rogers 給 HTC Magic 2.1 版的 ROM。（作法請參考 把玩"魔術師" -- 幫 boot.img 換 kernel）
                o Android 1.5 版的 Running Android AOSP on HTC Magic 32A Phones 的 "32A patch"。 

            作法二： 自行編譯 kernel；目前使用 Old Radio（3.22 版）的有 CM 的 kernel，以及使用 New Radio（6.35 版）的 HTC 的 kernel。編譯 HTC kernel 的方式請參考 把玩"魔術師" -- 編譯 HTC Kernel 原始碼。 

   5. 把新編譯的 kernel 和無線網路的驅動程式複製到適當的位置 -- ~/froyo/device/htc/dream-sapphire/。指令為

        cp ~/froyo/kernel/arch/arm/boot/zImage ~/froyo/device/htc/dream-sapphire/kernel
        cp ~/froyo/system/wlan/ti/sta_dk_4_0_4_32/wlan.ko ~/froyo/device/htc/dream-sapphire/wlan.ko
        

   6. 請在 device/htc/dream-sapphire/BoardConfigCommon.mk 的第 49 行之後，新增一行在產生 boot.img 所需要的 base address 給 32A 的手機用，修改後，第 49 和 50 行設定如下：

        BBOARD_KERNEL_CMDLINE := no_console_suspend=1 console=null
        BOARD_KERNEL_BASE := 19200000
        

   7. 將專屬於 HTC Magic 手機的重要的程式庫納入 system.img。這些程式庫必須存在才能順利的編譯 Android，但是由於抓取的（或者說 HTC 提供的）都已經是舊版的（明確的說是 1.6 版），所以常常造成編譯出來的 image 檔雖然能夠在手機上執行，但是也造成許多程式（如之前提到的 Calendar 和 Music 等）無法順利執行的原因。

         1. 取得 HTC 的檔案，並解壓縮。抓取並解壓縮檔案的指令為

              wget --referer=http://developer.htc.com/google-io-device.html http://member.america.htc.com/download/RomCode/ADP/signed-google_ion-ota-14721.zip?
              mv signed-google_ion-ota-14721.zip sapphire_update.zip
              cd ~/froyo/device/htc/sapphire
              ./unzip-files.sh
              

            重要更新： 由於加拿大電信商 Rogers 以及美國電信商 T-Mobile 分別釋出了 Android 2.1 以及 2.2 （前者有 Sense UI，後者就是陽春的 Google UI；這可能是因為目前的更新是針對 32B 的手機，而該手機的記憶體有限所致），所以以上的 sapphire_update.zip 可以使用不同的來源。
                * 若使用 Rogers 的 2.1 版，可以下載 Rogers stock rom with root，下載後可以將檔案名稱從 Rogers_21_capychimp.zip 改成 sapphire_update.zip 即可。印象中，解出來的檔案只缺一個，也就是 libstagefrighthw.so，所以下一個步驟只需要刪除一行即可。
                * 若使用 T-Mobile 的 2.2.1 版，可以下載 Froyo OTA，下載後可以將檔案名稱從 e059adc603a3.signed-opal-ota-60505.e059adc6.zip 改成 sapphire_update.zip 即可。印象中，所需的檔案都有，因此下一個步驟可以省略。 

         2. 執行 unzip-files.sh 的過程中，總共有四個檔案找不到；這四個檔案分別是 libGLES_qcom.so、liblvmxipc.so、liboemcamera.so、libstagefrighthw.so。請修改 vendor/htc/sapphire/device_sapphire-vendor-blobs.mk 將包含該四個檔案的四行敘述刪除。 

   8. 編譯 Android 平台，編譯成功的話，會產生必要的 image 檔。
         1. 加入繁體以及簡體中文的支援，指令如下：

              cd ~/froyo
              

            並新增 buildspec.mk 檔案，在該檔案內加入

              CUSTOM_LOCALES:=zh_TW zh_CN
              

            在一些蒐集到的資料中，也顯示我們可以直接更改 build/target/product/full.mk，把第 43 行的

              $(call inherit-product, build/target/product/languages_small.mk)
              

            改成

              $(call inherit-product, build/target/product/languages_full.mk)
              

         2. 設定編譯的平台，包含以下指令：

              source build/envsetup.sh
              lunch full_sapphire-userdebug  # 也可以執行 lunch 並選擇平台
              

            lunch 指令後面那一串字包含一些重要資訊，我們把它拆開來看：第一個 aosp 也可以是 full，目前我不清楚它的差異；第二個 sapphire 代表 Magic 32A，可以是 dream，也可以是 generic（代表基本型，僅適用模擬器）；第三個是 us（代表美國），另一個是 eu（代表歐洲）；最後一個是 eng（代表有 root 權限），也可以是 userdebug（代表一般環境）。

         3. 執行 make -j2 編譯 image 檔；這會需要一段時間，完成後在 ~/froyo/out/target/product/sapphire 內可以看到 image 檔。 

   9. 複製必要的字形檔，然後將新的字形檔與之前的結果，重新整理到 system.img 中。

        cp frameworks/base/data/fonts/DroidSansFallback.ttf  out/target/product/sapphire/system/fonts/
        make snod
        


