* pycharm shortkey
编辑类：

Ctrl + D             复制选定的区域或行
Ctrl + Y           删除选定的行
Ctrl + Alt + L     代码格式化
Ctrl + Alt + O     优化导入（去掉用不到的包导入）
Ctrl + 鼠标        简介/进入代码定义    
Ctrl + /           行注释 、取消注释

Ctrl + 左方括号   快速跳到代码开头
Ctrl + 右方括号   快速跳到代码末尾
Shift + F10        运行
Shift + F9         调试

查找/替换类：

Ctrl + F          当前文件查找
Ctrl + R          当前文件替换
Ctrl + Shift + F  全局查找
Ctrl + Shift + R  全局替换 

运行类：

Shift + F10        运行
Shift + F9         调试
Alt + Shift + F10  运行模式配置
Alt + Shift + F9   调试模式配置

调试类：

F8                单步调试（一行一行走）
F7                进入内部
Shift + F8        退出
Ctrl + F8         在当前行加上断点/断点开关
Ctrl + Shift + F8 查看所有断点

导航类：

Ctrl + N          快速查找类（也可查找当前工程中的文件，以文件名查找）
Double Shift      任意位置查找  


* iota importing after it satrt
/local/ltemme/iota/itasiotaserver -s 540 -c ./runiotaflex -a TA -p 2121
...
iota>
telnet 127.0.0.1 2121
iota> source tmp.tcl  ###messageTemplates.tcl procedure.tcl IOTAinterfaceProcedures.tcl

sending IOTA command: lappend interface_procs 4gAttachImsi 4gAttachGutiFromPtmsiGn .....

source postInitProcs.tcl 'base/iota_files/stateMachines.tcl',

kw "NEC Configure IOTA Simulator"
debug set in ota prompt
telnet 0 2121   # from a GASHPC window
at the iota> prompt
iota> enablelog S

disconnect from IOTA session window:
Esc
ctrl-] Enter # takes you to telnet prompt, then enter quit

use log "" to print out message in the log file instead of using puts "" , it will only in prompt window


* iota source code
>iota 
>iota_help 4gAttachImsi
>parray ::c_ue *csrsp_tgt_cause_bearer*
>parray ::c_ue 

**
self.iota_script(
            'base/iota_files/messageTemplates.tcl',
            'base/iota_files/success.vfy')
        self.iota_script(
            'base/iota_files/procedures.tcl',
            'base/iota_files/success.vfy')
        self.iota_script(
            'base/iota_files/IOTAinterfaceProcedures.tcl',
            'base/iota_files/success.vfy')
        self.iota_script(
            'base/iota_files/stateMachines.tcl',
            'base/iota_files/success.vfy')
        self.iota_script(
            'base/iota_files/postInitProcs.tcl',
            'base/iota_files/success.vfy')



########### postInitProcs.tcl:
---------------------------------------------------------------
 if {$argarray(-uenwcp) != "" && $argarray(-uenwcp) != "EMPTY"} {
          set _uenw_mmercv $argarray(-uenwcp)
          switch $argarray(-proc) {
             "attach" {
                   set ::c_ue(attachreq_uenwcapability) $_uenw_mmercv
             }
--------------------------------------------------------------------------------
this will insure this working:
4gAttach -postinitproc{ set ::c_ue(attachreq_uenwcapability) \$E0E0000040 }


############stateMachines.tcl
----------------------------------------  
		set ::CSM::TRIGGER(BLD_CREATESESSIONRSP_TGT_TRIGGER) {
			set ::c_ue(tgt_sgw) [lclNEof $_MSG]
			set ::c_ue(csrsp_tgt_recovery) [ $::c_ue(tgt_sgw) get recovery ]
			set ::c_ue(csreq_tgt_teid_mme) \$[string range $::c_ue(csreq_tgt_senderteid) 3 10]
			set ::c_ue(csrsp_tgt_senderteid) [UEMgmt::GenerateFteid ${::c_ue(tgt_sgw)} 11]
			set ::c_ue(csrsp_tgt_teid_sgw) \$[string range $::c_ue(csrsp_tgt_senderteid) 3 10]
			set ::c_ue(csrsp_tgt_s1usgwteid) [UEMgmt::GenerateFteid ${::c_ue(tgt_sgw)} 1]
		set ::csrsp_tgt_s1usgwteid [UEMgmt::GenerateFteid ${::c_ue(tgt_sgw)} 1]
		set ::c_ue(tgt_sgw_ipupaddr) \$[UEMgmt::GetSgwSimIpUpAddress $::c_ue(tgt_sgw)]
#		puts "::c_ue(tgt_sgw_ipupaddr)    $::c_ue(tgt_sgw_ipupaddr) "
		set ::c_ue(csrsp_tgt_s1usgwteid) [string range $::csrsp_tgt_s1usgwteid 0 2]00010001[string range $::c_ue(tgt_sgw_ipupaddr) 1 end]
			set ::c_ue(csrsp_tgt_cause) \$4300
			set ::c_ue(csrsp_tgt_cause_bearer) \$1000
			set ::c_ue(csrsp_tgt_bearerqos) EMPTY
			#
			set ::c_ue(csrsp_tgt_pgws5s8addr) [UEMgmt::GenerateFteidUsingHexAddr [string range $::c_ue(csreq_tgt_pgws5s8addr) 11 end] 7]
			set ::c_ue(csrsp_tgt_paa) \$01c0a80164  ### no matter what's the initial value of this, it will be overided as this value.
----------------------------------------------------------          
4gAttachImsi -verbose 1  -postinitproc {set ::c_ue(csrsp_tgt_cause_bearer) \$4300}
iota_help
set ::c_ue(csrsp_tgt_cause) \$4300}

4gAttachImsi -verbose 1  -postinitproc {set ::c_ue(csrsp_tgt_cause) \$4300}
4gAttachImsi -verbose 1  -postinitproc {set ::c_ue(csrsp_tgt_paa) EMPTY}
4gAttachImsi -verbose 1  -imsi 460020301001004
set ::c_ue(csrsp_tgt_paa)  EMPTY/

http://10.102.125.62/iota_loads/iota_v3_tag0026.tar.gz
 curl -O http://10.102.125.62/bin/itasiotaserver &amp;&amp; chmod 755 itasiotaserver'
cd  /local/ltemme/iota/itasiotaserver 
/local/ltemme/iota/itasiotaserver -s 540 -c ./runiotaflex -a TA -p 2121


Current installed IOTA version: 'iota_v3_tag0026'
Configuring the IOTA Simulator
Sending IOTA procedure: "CreateS11uSGW -name sgws11u -ip 172.16.49.119 -port 2152 -mmeip 172.16.46.12 -mmeport 2152" using verify string "established"
udo /usr/sbin/tcpdump -i any -w /tmp/mme_001.pcap -C 100 -W 1 &


iota> parray ::c_ue MSPEC_CSRSP_TGT_BCLISTCREATED
parray ::c_ue MSPEC_CSRSP_TGT_BCLISTCREATED


#############
>>>>>> SEND MESSAGE TEMPLATE: basic_snd_createsessionrsp_tgt
ERROR: GTPSet::encodeField Missing mandatory field [BCLISTCREATED] while encoding field [CREATESESSIONRSP]
---------------------------------------------------------------------------------------------------------
#	UEMgmt::GenerateGTPBearerIE -ie MSPEC_CSRSP_TGT_BCLISTCREATED -map $_iemap
		    set ::c_ue(MSPEC_CSRSP_TGT_BCLISTCREATED) "{ {BCLISTCREATED EMPTY} }\n"
----------------------------------------------------------------------------------------------------------
CSM::CSM_STATE_MACHINE ::CSM::sm_createSessionReq_tgt {
	set msgType [typeof $_MSG]
	if { $_state == "init" } {
		# state machine local init here
		set _state "waitforcsr"
	}
	switch $_state {
		"waitforcsr" {
			switch $msgType {
				"CREATESESSIONREQ" {
				set ::c_ue(tgt_sgw) [lclNEof $_MSG]
				set ::c_ue(mme_link) [rmtNEof $_MSG]
					eval $::CSM::TRIGGER(PRE_CREATESESSIONREQ_TGT_TRIGGER)
					db update $::c_ue(rcv_createsessionreq_tgt) -mapping ::c_ue
					retrieve $_MSG -msg $::c_ue(rcv_createsessionreq_tgt) -mapping ::c_ue
					eval $::CSM::TRIGGER(POST_CREATESESSIONREQ_TGT_TRIGGER)
					eval $::CSM::TRIGGER(BLD_CREATESESSIONRSP_TGT_TRIGGER)
					eval $::CSM::TRIGGER(PRE_CREATESESSIONRSP_TGT_TRIGGER)
					send $::c_ue(mme_link) <- $::c_ue(tgt_sgw) -msg $::c_ue(snd_createsessionrsp_tgt) -mapping ::c_ue  ##if comment out, no createsessionrsp will be sent
					eval $::CSM::TRIGGER(POST_CREATESESSIONRSP_TGT_TRIGGER)
					set _state "done"
				}
				default {
					error ""
				}
			}
		}
		default {
			error ""
		}
	}
}


#817 proc enbatt
# scen_common_chain addchainedsm "CREATESESSIONREQ" $::CSM::sm_createSessionReq_tgt init done
# if comment out the whole createsessionreq will be fail
-----------------------------------------------------------
scen_common_chain FAILED.  Error Info:
Unexpected Message Received: GTP {{BODY {@CREATESESSIONREQ {{APN wap1.nokia.com.mnc002.mcc460.gprs} {APNAMBR $00002710000186A0} {BCLISTCREATED {+ {{BEARERQOS $7D090000000000000000000000000000000000000000} {EPSBEARERID $05}}}} {CHARGINGCHAR $3132} {IMSI $64000203011000F1} {INDICATIONFLAGS $00180000000202} {MAXAPNRES $00} {MEI $8967452391785634} {MSISDN $537840062000} {PAA $01C0A80164} {PDNTYPE $01} {PGWS5S8ADDR $8700000000AC103179} {RATTYPE $06} {RECOVERY $02} {SELECTIONMODE $00} {SENDERTEID $CA0000000EAC102E7025110000000009930000000000000009} {SERVINGNETWORK $64F020} {UETIMEZONE $2101} {ULI $1864F020640164F02000414101} {ULISGW $1864F020640164F02000414101}}}} {MSGPRIORITY EMPTY} {PBMSG EMPTY} {SEQNUM $2000A2} {TEID $00000000} {localName s11sgw01} {remoteName mme_net1}}
    while executing
"error "$_errorinfo""
    (object "::scen_common_chain" method "::Scenario::invokechain" body line 64)
    invoked from within
"invokechain"
    ("while" body line 6)
    invoked from within
"while { [chaincomplete] != "true" } {
		recv * -> * -timeout $::CSM::MSGTIMEOUT -abort false
		if { $_MSG == "" } {
			break
		} else {
			invokechain..."
    ("eval" body line 8)
    invoked from within
"eval $_script "
----------------------------------------------------------

>>>>>> SEND MESSAGE TEMPLATE: basic_snd_ula
State machine ULR successfully processed message ULR; _state=done endstate=done
=========================
+++
GTP {{BODY {@CREATESESSIONREQ {{APN wap1.nokia.com.mnc002.mcc460.gprs} {APNAMBR $00002710000186A0} {BCLISTCREATED {+ {{BEARERQOS $7D090000000000000000000000000000000000000000} {EPSBEARERID $05}}}} {CHARGINGCHAR $3132} {IMSI $64000203011000F1} {INDICATIONFLAGS $00180000000202} {MAXAPNRES $00} {MEI $8967452391785634} {MSISDN $537840062000} {PAA $01C0A80164} {PDNTYPE $01} {PGWS5S8ADDR $8700000000AC103179} {RATTYPE $06} {RECOVERY $02} {SELECTIONMODE $00} {SENDERTEID $CA02000003AC102E7025110000000009930000000000
mme_net1 ---- CREATESESSIONREQ ---> s11sgw01

Begin invokechain procedure
Invoking state machine AIR with _state=done endstate=done for message CREATESESSIONREQ
Invoking state machine AUTHREQ with _state=done endstate=done for message CREATESESSIONREQ
Invoking state machine SECMODE with _state=done endstate=done for message CREATESESSIONREQ
Invoking state machine IDREQIMEI with _state=init endstate=done for message CREATESESSIONREQ
Invoking state machine ULR with _state=done endstate=done for message CREATESESSIONREQ
Invoking state machine CREATESESSIONREQ with _state=init endstate=done for message CREATESESSIONREQ
>>>>>> RECV MESSAGE TEMPLATE: basic_rcv_createsessionreq_tgt
mme_net1 <--- CREATESESSIONRSP ---- s11sgw01
+++
GTP {{BODY {@CREATESESSIONRSP {{APNRES $00} {BCLISTCREATED {+_list {{CAUSE $1000} {EPSBEARERID $05} {S1USGWTEID EMP00010001AC1031D3} {S5S8UPGWTEID $8500000051AC1031DD}}}} {CAUSE $4300} {PGWS5S8ADDR $8700000050AC103179} {RECOVERY 1} {SENDERTEID $8B0000004EAC10316F}}}} {SEQNUM $200088} {TEID $02000003} {localName s11sgw01} {remoteName mme_net1}}

>>>>>> SEND MESSAGE TEMPLATE: basic_snd_createsessionrsp_tgt
State machine CREATESESSIONREQ successfully processed message CREATESESSIONREQ; _state=done endstate=done
================================================================================

openstack_controller.py
-----------------------------
necc ip for 131A is  10.40.174.7
_secure_passwords = {
        'cmm': 'Nokia_1234',
        'root': 'Nokia_1234',
        'liuser': 'Nokia_1234',
        'sam5620': 'CMMsam@1234',
        'cbamuser': 'Nokia_1234',
    }
    _onetime_passwords = {
        'cmm': '2pe1qlP4zjXt',
        'root': '39pfMBw3W8ec',
        'liuser': 'Nokia_1234',
        'sam5620': 'dipq2zlPLv36',
        'cbamuser': 'KX6GQrNagFSw',
    }


HOST = '10.40.174.7'

CONSOLE = '10.40.174.3'
CONTROLLER = '10.40.174.3'


Cmm Command cmm nrfCacheAdmin modify --nrfCacheOperation FLUSH_CACHE
http://10.102.202.45:8080/job/03_AMF_CMM_smoke/3913/artifact/IPC-TCL-20/result/log.html



* check the subscribers in database



[cmm@espate137a-necc0 ~]$ cmm subscribers count
cmm: 'subscribers count' is not a cmm command. See 'cmm --help'.
Did you mean one of these?
  subscriber count
    subscriber delete
      subscriber show
      [cmm@espate137a-necc0 ~]$ cmm subscriber count
      +---------+-------+
      | Field   | Value |
      +---------+-------+
      | Sum     |     0 |
      | Filters |    {} |
      +---------+-------+
 [cmm@espate137a-necc0 ~]$ sudo serfclient -t '*dbs*' -c cmd.run.ssh -p "echo 'dbsize' | redis-cli -p 6379; echo 'dbsize' | redis-cli -p 6380"
      +------------+----------+
      | hostname   | response |
      +------------+----------+
      | dbs0.local | 0        |
      |            | 0        |
      +------------+----------+
      | dbs1.local | 0        |
      |            | 0        |
      +------------+----------+
      | dbs2.local | 0        |
      |            | 0        |
      +------------+----------+
      | dbs3.local | 0        |
      |            | 0        |
      +------------+----------+
      [cmm@espate137a-necc0 ~]$

* iota state machine and iota proc
**  IOTA Procedure
*** procedure recognized in command line
in iota command line, if you input some proc name, it could be invoked, is because the procedures 5g_IOTAinterfaceProcedures.tcl or IOTAinterfaceProcedures.tcl(for 4g)
to interface_procs by lappend
 lappend interface_procs 4gAttachImsi 4gAttachGutiFromPtmsiGn .....
iota> 

so if iota server not restart, any modification to 5g_IOTAinterfaceProcedures.tcl will not take effect, since, it was already sourced. 
resource it in your robot testcase
IOTA Script         base/iota_files/5g_messageTemplates.tcl
IOTA Script         base/iota_files/5g_IOTAinterfaceProcedures.tcl
IOTA Script         base/iota_files/5g_stateMachines.tcl
IOTA Script         base/iota_files/postInitProcs.tcl


*** add a interface procedure in 5g_IOTAinterfaceProcedures.tcl template
proc 5gPostReg_test  { args } {

    set reqargs [list]
    set optargs [list -postinitproc -verbose  -gNB ]

    set defaultArray(-verbose) $::verblevel
    set defaultArray(-gNB) gnb01
    array set argarray [getargs $args $reqargs $optargs defaultArray]
    parray argarray

    set ::c_ue(tgt_gnb) $argarray(-gNB)
    CSM::5gRegisAccept  
    ### this CSM defined in state machine file
    scen_common_chain verbose $argarray(-verbose)

    if {$argarray(-postinitproc) != ""} {
        eval $argarray(-postinitproc)
    }
    CSM::RunCSM scen_common_chain

    # We will get here only if no error was raised by previous procedures
    puts "IOTAPROCRETCODE=0"
    return 0
}
}





** iota state machine



*** a CSM procedure defined in file 5g_statemachine.tcl
**** procedure of state machine should be in CSM namespace
this procedure should be in
namespace eval CSM {     }  in the file 5g_stateMachine.tcl
-------------------------------------------------------------
proc 5gRegisAccept { args } {
###initialize state machine of scenario
		InitStateMachines    

###   if this proc is not a very complete procedure, it related to previous procedure too much then copy src to tgt value
        UEMgmt::CopySrcToTgt 

### set scenario trigger   if you want to trigger this by sending message firstly, 
		set ::CSM::SCENARIOTRIGGER {
         
			send amf_net1 <- $::c_ue(tgt_gnb) -msg $::c_ue(snd_ngsetupreq) -mapping ::c_ue
		}
###### if scenario firstly to receive some message, then set it as null
           set ::CSM::SCENARIOTRIGGER "" 

### add common chain into scenario
        scen_common_chain addchainedsm "NGSETUP" $::CSM::sm_NgSetupResponse_tgt_amf init done

#### standard procedure all the same below
       scen_common_chain verbose $argarray(-verbose)
    	if {$argarray(-postinitproc) != ""} { eval $argarray(-postinitproc) }  ## eval post initproc to change the default behavior
	   CSM::RunCSM scen_common_chain    ### start to run the scenario with trigger
        puts "IOTAPROCRETCODE=0"
        return 0
    }
---------------------------------------------------------------------------------------------
    proc RunCSM { scen } {
                    catch { $scen start }     ## this is similar to Scenario nssf_r16_test {..}  nssf_r16_test start       
---------------------------------------------------                    
when the test code is just like:
scen_common_chain send amf_net1 <- gnb01 -msg  -mapping ::c_ue

**** procedure of addchain
  scen_common_chain addchainedsm "N2_NGSETUP_FAILURE" $::CSM::sm_NgSetupFailure_tgt_amf init done

****  procedure to add CSM::TRIGGER
proc InitNonUeN2InfoSubscribeRequest_mod { args } {
    prepend ::CSM::TRIGGER(PRE_NLS_DETERMINELOCATIONREQUEST_AMF_TRIGGER) {
       set ::c_ue(snd_nonue_n2info_subscribe_hdrframe) "basic_amf_non_ue_n2_info_subscribe_hdrframe_req"
       set ::c_ue(snd_hdrblk_path)  "/namf-comm/v1/non-ue-n2-messages/subscriptions"
       puts "QQQp tty2"
       send amf_net1 <- lmf1_c -msg $::c_ue(snd_nonue_n2info_subscribe_hdrframe) -mapping ::c_ue
       send ${::TARGET_AMF_NET} <- $::c_ue(lmfsim_c) -msg $::c_ue(snd_nonue_n2info_subscribe_hdrframe) -mapping ::c_ue
    }
     prepend ::CSM::TRIGGER(PRE_Nls_NONUEN2MESSAGETRANSFERREQ_AMF_TRIGGER) {
        set ::c_ue(nonuemsgtransfer_contentid)   "nrppac_test"
     }
}



add this InitNonUeN2InfoSubscribeRequest_mod in the beginning of the IOTA Procedure <5GRegistration..>
-----
proc 5gMTLR { args } {
    InitNonUeN2InfoSubscribeRequest_mod  -lmfsim_c lmf1_c
....
}
=======
these need to be eval ed in the state machine
------------------------------------------
switch $msgType {
				"DETERMINELOCATIONREQ" {
					eval $::CSM::TRIGGER(PRE_NLS_DETERMINELOCATIONREQUEST_AMF_TRIGGER)
					db update $::c_ue(rcv_data_NLsDetermineLocation) -mapping ::c_ue
------------------------------------

**** add_delay

5gMTLR -positioning nonue_nrppa -postinitproc { 
scen_common_chain addchainedsm "NONUEN2INFOSUBSCRIBERREQUEST" $::CSM::sm_nonUeN2InfoSubscribe init done;
add_delay -state PRE_NLS_DETERMINELOCATIONRESPONSE_LMF_TRIGGER -delay 50000 -removeSm false; }

in state machine, when evalute this trigger, it will delay 50000 ms?
--------------------
 eval $::CSM::TRIGGER(PRE_NLS_DETERMINELOCATIONRESPONSE_LMF_TRIGGER)
- ---------------------

========
add_delay: Time before delay: "Thu, 31 Mar 2022 08:52:17 GMT"
add_delay: Time after delay: "Thu, 31 Mar 2022 08:53:07 GMT"
amf_net1_3 <--- HEADERSFRAME ---- lmf1_s
+++
HTTP2 {{BODY {@HEADERSFRAME {{FLAGS $04} {HDRBLKFRAGMENT {{STATUS "200"} {TGPPSBIPRODUCERID EMPTY}}} {STREAMID $00000001}}}} {localName lmf1_s} {remoteName amf_net1_3}}

>>>>>> SEND MESSAGE TEMPLATE: basic_snd_lmf_determine_location_res_hdrframe_tgt_amf
amf_net1_3 <--- DATAFRAME(DETERMINELOCATIONRSP) ---- lmf1_s
============

CSM::CSM_STATE_MACHINE ::CSM::sm_nonUeN2InfoSubscribe {...}
append ::CSM::TRIGGER(PRE_NLS_DETERMINELOCATIONRESPONSE_LMF_TRIGGER) {
         |                       set ::c_ue(snd_lmf_determine_location_res_hdrframe)   snd_lmf_determine_location_problemdetails_hdrframe_rsp
                 |                       set ::c_ue(snd_lmf_problemdetails_hdr_status)         $::f20018_params(lmf_status)
                                         }



****  state machine defined not in CSM scope
CSM::CSM_STATE_MACHINE ::CSM::sm_NgSetupResponse_tgt_amf {
	    ::CSM::validate [lclNEof $_MSG] $::c_ue(tgt_gnb) ""
        if { $_state == "init" } {
                set _state "waitforngsetuprsp"
        }
        set msgType [typeof $_MSG]
        switch $_state {
            "waitforngsetuprsp" {
		         switch $msgType {
		               "NGSETUPRESPONSE" {
                             eval $::CSM::TRIGGER(PRE_RCV_NGSETUPRESPONSE_TGT_AMF_TRIGGER)
			                 db update $::c_ue(rcv_ngsetuprsp) -mapping ::c_ue
			                 retrieve $_MSG -msg $::c_ue(rcv_ngsetuprsp) -mapping ::c_ue
                             eval $::CSM::TRIGGER(POST_RCV_NGSETUPRESPONSE_TGT_AMF_TRIGGER)
                             set _state "done"
		               }
		               default {
			                 error ""
		               }
		         }
	        }
	        default {
		                error ""
	        }
	    }
}

--------------------------------

***** scenario trigger handled firstly in state machine(in CSM::SCENARIOTRIGGER) 

proc ::ngSetupRetry {  } {
           set ::CSM::SCENARIOTRIGGER {
                     send amf_net1 <- $::c_ue(tgt_gnb) -msg $::c_ue(snd_ngsetupreq) -mapping ::c_ue

                     # Resend NGAPRESET if no ACK from AMF for 10 sec (1 re-transmissions)
                     set ::c_ue(resetack_rcvd) false
                     for {set i 0} {$i < 20} {incr i } {
                        recv amf_net1 -> * -timeout 10 -abort false   ### when this recv invoke it couldn't be used in invokechain, so it will be put at the beginning, CSM::SCENARIOTRIGGER
                        if { $_MSG == "" } {
                             send amf_net1 <- $::c_ue(tgt_gnb) -msg $::c_ue(snd_ngsetupreq) -mapping ::c_ue
                         } else {
                             set msgType [typeof $_MSG 1]
                             if {$msgType != "NGSETUPRESPONSE"} {
                                send amf_net1 <- $::c_ue(tgt_gnb) -msg $::c_ue(snd_ngsetupreq) -mapping ::c_ue
                             } else {
                                     set ::c_ue(resetack_rcvd) true
                                     break
                             }
                        }
                    }
                    if {$::c_ue(resetack_rcvd) == "false" } {
                        error "ERROR: No NGAPRESETACK from AMF......"
                    }
           }
           scen_common_chain removechainedsm "NGSETUP"
}      


  IOTA Procedure    5gNgSetup   -ta1 ${IOTA.AMF_TAC1}:${CMM.MCC}${CMM.MNC}:01:D143A5 -gNB gnb04 -gnbname gnb04 -postinitproc {::ngSetupRetry}


proc 5gNgSetup { args } {
.....
    array set argarray [getargs $args $reqargs $optargs defaultArray]
    parray argarray

	CSM::InitNGapSetup -gNB $argarray(-gNB) -expectrlsbrr $argarray(-expectrlsbrr) -ngsetupfailure $argarray(-ngsetupfailure)
...
    scen_common_chain verbose $argarray(-verbose)
	if {$argarray(-postinitproc) != ""} { eval $argarray(-postinitproc) }
	CSM::RunCSM scen_common_chain
        puts "IOTAPROCRETCODE=0"
        return 0
}


proc InitNGapSetup { args } {
		array set argarray [getargs $args [list -gNB] [list "-expectrlsbrr" "-ngsetupfailure"]]
		InitStateMachines

####  CSM::SCENARIOTRIGGER could be override in postinitproc if you reset it
		set ::CSM::SCENARIOTRIGGER {
			send amf_net1 <- $::c_ue(tgt_gnb) -msg $::c_ue(snd_ngsetupreq) -mapping ::c_ue
		}

        if {$argarray(-ngsetupfailure) == "true" } {
            scen_common_chain addchainedsm "N2_NGSETUP_FAILURE" $::CSM::sm_NgSetupFailure_tgt_amf init done
        } else {
            scen_common_chain addchainedsm "NGSETUP" $::CSM::sm_NgSetupResponse_tgt_amf init done
        }
		set ::c_ue(snd_ngsetupreq) basic_snd_ngsetuprequest_tgt_amf
		set ::c_ue(rcv_ngsetuprsp) basic_rcv_ngsetupresponse_tgt_amf
		set ::c_ue(rcv_ngsetupfailure) basic_rcv_ngsetupfailure_tgt_amf


    }
***  abort a procedure advancely
in IOTA procedure, we can end a chain state machine, but other state machine should be removed
**** abort a state machine, in some step insert below:
##   ...           append ::CSM::TRIGGER(PRE_ULA_TRIGGER) {
##   ...               set _state "done"; ::CSM::BREAK}}

**** remove all the following procedure
-verbose=1  running a successfuly procedure
remove all these st as follow:
State machine updateBrrRsp successfully processed message UPDATEBEARERRSP; _state=done endstate=done
  ...        scen_common_chain removechainedsm "updateBrrRsp";



***  receive the same multiple message in a chain
CSM::CSM_STATE_MACHINE ::CSM::sm_N2Paging_tgt_amf {
	if {$::vfy_rcv_gnb == "true" } {
	    ::CSM::validate [lclNEof $_MSG] $::c_ue(tgt_gnb) ""
	}
	set msgType [typeof $_MSG]
	if { $_state == "init" } {
		# state machine local init here
		set _state "waitfor_paging"
		set ::c_ue(numrecvpage) 1
		if { [info exist ::c_ue(page_attempts)] != 1 } { set ::c_ue(page_attempts) 1 }
	}
	switch $_state {
		"waitfor_paging" {
			switch $msgType {
				"PAGING" {
					eval $::CSM::TRIGGER(PRE_N2PAGING_TGT_AMF_TRIGGER)
					db update $::c_ue(rcv_n2paging) -mapping ::c_ue
					retrieve $_MSG -msg $::c_ue(rcv_n2paging) -mapping ::c_ue
					set ::c_ue(gnb_page) [lclNEof $_MSG]
					eval $::CSM::TRIGGER(POST_N2PAGING_TGT_AMF_TRIGGER)
					if {$::c_ue(numrecvpage) == $::c_ue(page_attempts) } {
					    # No longer expecting additional paging attempts from the AMF...
					    unset ::c_ue(page_attempts)
					    eval $::CSM::TRIGGER(PRE_N2PAGING_PRE_SR_TGT_AMF_TRIGGER)
					    eval $::CSM::TRIGGER(POST_N2PAGING_SR_TGT_AMF_TRIGGER)
					    eval $::CSM::TRIGGER(POST_N2PAGING_POST_SR_TGT_AMF_TRIGGER)
					    set _state "done"
					} else {
					    incr ::c_ue(numrecvpage)
					    set _state "waitfor_paging"
					}

				}
				default {
					error ""
				}
			}
		}
		"done" {
			error ""
		}
		default {
			error ""
		}
	}
}

*** bearer related variable setting
 $::UEBearers setsgwconnections -tgtmme $::c_ue(csreq_tgt_senderteid) -tgtsgw $::c_ue(csrsp_tgt_senderteid)

** iota framework message definition
*** real scenario definition in iota framework
entry of a iota test procedure:
in procedures.tcl file:


catch { delete obj scen_common_chain }
Scenario scen_common_chain {

	# Specify which message template database to use
	useMTDB db
        showscripts  #### add this line could show all of the statemachine as: State Machine: AIR (#0)  startstate: init  endstate: done  currentstate: init  optional: false
                     ###    State Machine: AUTHREQ (#1)  startstate: init  endstate: done  currentstate: init  optional: false
	eval $::CSM::SCENARIOTRIGGER   ### if you want to recive message in your own chain, put it here, 
                                   ### the first step, generally send some message, then receive the message next step

	while { [chaincomplete] != "true" } { ### when a chain process the msg, it will set _state=done, then next time inokechain tranverse it, the "done" switch will return and do nothing
		recv * -> * -timeout $::CSM::MSGTIMEOUT -abort false
		if { $_MSG == "" } {
			break
		} else {
			invokechain    #### until no mandatary st not done, every time the chain who process the message will break the chain tranverse 
		}
	}

   if { [chaincomplete] != "true" } {
      # at least one state machine did not complete, dump out all state machines and treat as error.
      showscripts
      error "All state machines did not complete."
   }
   # Account for optional messages after all required
   # state machines completed
  if { $::CSM::SCENARIOPROCESSEXTRAMSG == "true" } {
      set optcnt 0
      while {$optcnt < 5} {
          incr optcnt
         recv * -> * -timeout $::CSM::SCENARIOGUARDTIMER -abort false
         if { $_MSG != "" } {
             invokechain
         } else {
             break
         }
      }
  } else {
      # make sure we don't get any unexpected messages
      recv * -> * -timeout $::CSM::SCENARIOGUARDTIMER -abort false
      if { $_MSG != "" } {
               error "received unexpected message: [$_MSG display]"
      }
   }
   eval $::CSM::POSTSCENARIOCOMMANDS

}


*** Scenario.tcl invokechain proc
###everytime invoking a chain, the sm which wasn't reach error will get $i = 0, then the tranverse in the chindsms will break; 
....
                       set _chainedsms [lreplace $_chainedsms $myidx $myidx [array get smarray]]
                        if { $i == 0 } {
                                # state machine successfully processed message
                                if { $_verbose > 0 } {
                                        puts "State machine $smarray(name) successfully processed message [typeof $_MSG 1]; _state=$_state endstate=$_endstate"
                                }
                                break
                        }




*** message definition in iota framework
*.msgd file contains the definition of messages:
ctpapp/lte/eps/msg/nudm.msgd
----------------------------------------------------
..
**** field type string
string size is how many characters of the string like "1234"
set size 0x0004

**** filed type int
#range 0 to 9
field:AdditionalTnlNbInt
       set desc "AdditionalTnlNb"
       set size 0x0001
###        
       set size 0x0002   #### range 11 to 99
       set size 0x0001~0x0002   #### range 1 to 99


field:MessageLength
        set desc "Message Length"
        set size 2
        set class "GPD::Octet"
end

message:NUDMMsg
        set desc "NUDM Message"
begin
        Body
end

choice:Body
        set desc "Message Body Definition"
        set idflddef MessageType
begin
        0x01            uecmregistrationreq
        0x14            uecmregistrationrsp
        0x02            uecmregistrationrspfail
        0x03            deregistrationnotify

..
## Reference: DeregistrationData
set:deregistrationnotify
        set desc "UECM Deregistration Notify Message"
        set jsontype "message"
        set jsonname "DeregistrationNotify"
        set  version 1520180900
begin
        DEREGREASON             :       deregReasonStr          -M     ### here deregReasonStr is the ie field type, and DEREGREASON is the message ie field
        ACCESSTYPE              :       accessTypeStr           -M
end

field:deregReasonStr
        set desc "Deregistration Reason String"
        set size 0x0001~0x0064
        set jsontype "string"
        set jsonname "deregReason"        ### the jsonname is in real http2 message value
end
-------------------------------------------------------------------------

*** template def
*.tcl
-------
db loadTemplate {define udm_deregistration_notify_dataframe_req {
HTTP2MSG {
   {BODY {@DATAFRAME {
         {FLAGS %data_flags}
         {STREAMID %data_streamid}
         {DATA {
            NUDMMSG {
               {BODY {@DEREGISTRATIONNOTIFY {
                  {DEREGREASON "SUBSCRIPTION_WITHDRAWN"}   DEREGREASON is the field name, but in http2 json, it will be : "deregReason":"SUBSCRIPTION_WITHDRAWN"
                  {ACCESSTYPE "3GPP_ACCESS"}
               }}}
            }
         }}
      }
   }}
}
}}
----------------------------------------------------------                   

json:  JavaScript Object Notation
this will be in the http2 DATA frame


*** sdt for messge id
file ctpapp/lte/eps/sim/http2blk.sdt
---------------------------------------------------------------------------
// NUDM/N8 Services
servicetype[nudm-uecm-put],                     ReadWrite,      Dictionary
servicetype[nudm-uecm-put][nftype],             ReadWrite,      "udm"
servicetype[nudm-uecm-put][5],                  ReadWrite,      1       // uecm-registration-req
### PUT /nudm-uecm/v1/imsi-460020301001001/registrations/amf-3gpp-access, DATA[1] (application/json)
### 5 means /1/2/3/4/5    

servicetype[nudm-uecm-put][statusmsg],          ReadWrite,      Dictionary
servicetype[nudm-uecm-put][statusmsg][201],     ReadWrite,      20      // uecmregistrationrsp
servicetype[nudm-uecm-put][statusmsg][403],     ReadWrite,      2       // uecmregistrationrspfail
servicetype[nudm-uecm-put][statusmsg][404],     ReadWrite,      2       // uecmregistrationrspfail

servicetype[nudm-uecm-post],                    ReadWrite,      Dictionary
servicetype[nudm-uecm-post][nftype],            ReadWrite,      "udm"
servicetype[nudm-uecm-post][6],                 ReadWrite,      3       // deregistration-notify
###  POST /nudm-uecm/v1/imsi-460020301001001/registrations/amf-3gpp-access/notification
###       /1/2/3/4/5/6
------------------------------------------------------------------------------


* IOTA/ATE DNS env
'dnsConfigName': 'config', 'priDnsIp': '172.16.0.254', 'secDnsIp'
root/tigris
cd /etc/bind
[root@espate137a bind]# cat named.3gppnetwork.org
$ORIGIN .
$TTL 60 ; 1 minute
3gppnetwork.org         IN SOA  localhost. root.localhost. (
                                2          ; serial
                                604800     ; refresh (1 week)
                                3600       ; retry (1 hour)
                                604800     ; expire (1 week)
                                600        ; minimum (10 minutes)
                                )
                        NS      localhost.
$ORIGIN 3gppnetwork.org.
$TTL 3600       ; 1 hour
pgw002.mme100.pool2.nodes.epc.mnc002.mcc02 NAPTR 3600 100 "a" "x-3gpp-pgw:x-s5-gtp:x-s8-gtp" "" topon.eth1.pgw002.mme100.pool2.nodes.epc.mnc002.mcc460
$ORIGIN nokia.com.apn.epc.mnc002.mcc460.3gppnetwork.org.
#####createsessionreq will use this wap1.nokia.com.anp.epc.mnc002.mcc02
wap1                    NAPTR   100 65530 "a" "x-3gpp-pgw:x-s5-gtp:x-s8-gtp:x-gn:x-gp" "" topon.eth1.pgw001.mme100.pool1.nodes.epc.mnc002.mcc460.3gppnetwork.org.
                        NAPTR   100 65530 "a" "x-3gpp-pgw:x-s5-gtp:x-s8-gtp:x-gn:x-gp" "" topon.eth1.pgw002.mme100.pool2.nodes.epc.mnc002.mcc460.3gppnetwork.org.
wap2                    NAPTR   100 65530 "a" "x-3gpp-pgw:x-s5-gtp:x-s8-gtp:x-gn:x-gp" "" topon.eth1.pgw001.mme100.pool1.nodes.epc.mnc002.mcc460.3gppnetwork.org.
                        NAPTR   200 65530 "a" "x-3gpp-pgw:x-s5-gtp:x-s8-gtp:x-gn:x-gp" "" topon.eth1.pgw002.mme100.pool2.nodes.epc.mnc002.mcc460.3gppnetwork.org.
wap3                    NAPTR   200 65530 "a" "x-3gpp-pgw:x-s5-gtp:x-s8-gtp:x-gn:x-gp" "" topon.eth1.pgw002.mme100.pool2.nodes.epc.mnc002.mcc460.3gppnetwork.org.
wap4                    NAPTR   200 65530 "a" "x-3gpp-pgw:x-s5-gtp:x-s8-gtp:x-gn:x-gp" "" topon.eth1.pgw002.mme100.pool2.nodes.epc.mnc002.mcc460.3gppnetwork.org.
wap5                    NAPTR   100 65530 "a" "x-3gpp-pgw:x-s5-gtp:x-s8-gtp:x-gn:x-gp" "" topon.eth1.pgw001.mme100.pool1.nodes.epc.mnc002.mcc460.3gppnetwork.org.
                        NAPTR   100 65530 "a" "x-3gpp-pgw:x-s5-gtp:x-s8-gtp:x-gn:x-gp" "" topon.eth1.pgw002.mme100.pool2.nodes.epc.mnc002.mcc460.3gppnetwork.org.
wap6                    NAPTR   100 65530 "a" "x-3gpp-pgw:x-s5-gtp:x-s8-gtp:x-gn:x-gp" "" topon.eth1.pgw001.mme100.pool1.nodes.epc.mnc002.mcc460.3gppnetwork.org.
                        NAPTR   200 65530 "a" "x-3gpp-pgw:x-s5-gtp:x-s8-gtp:x-gn:x-gp" "" topon.eth1.pgw002.mme100.pool2.nodes.epc.mnc002.mcc460.3gppnetwork.org.
$ORIGIN com.apn.epc.mnc002.mcc460.3gppnetwork.org.
wapEmerg.verizon        NAPTR   100 65530 "a" "x-3gpp-pgw:x-s5-gtp+nc-smf:x-s8-gtp+nc-smf:x-gn:x-gp" "" topon.lb1.pgwEmerg.pool1.nodes.epc.mnc002.mcc460.3gppnetwork.org.
$ORIGIN mme.epc.mnc002.mcc460.3gppnetwork.org.
$TTL 100        ; 1 minute 40 seconds
topon.eth1.extMmePapsGn A       172.16.49.91


[root@espate137a bind]# cat named.gprs
$ORIGIN nokia.com.mnc002.mcc460.gprs.
wap1                    A       172.16.49.121
                        A       172.16.49.122
wap10                   A       172.16.49.122
wap11                   A       172.16.49.122
wap2                    A       172.16.49.122
wap3                    A       172.16.49.122
wap4                    A       172.16.49.122
wap5                    A       172.16.49.122


** iota case fail troubleshooting
*** "invalid command name gnb01"
Sending IOTA procedure: "5gRegistrationSuci -for true" using verify string "IOTAPROCRETCODE=0"
ERROR invalid command name "gnb01"

redploy ATE env, gash server will be redeployed


* iota  framework development
** iota ngap 
containing (remove this)
uppercase/lowercase ignore dash will be removed
criticality ignore/reject   ......this is the default value but message definition in iota couldn't control it, 
                           ....... just in template
messages/ies two different level                           

** iota buiding
working dir is 1_iota with some building tools in its dir, git iota don't contain these
$ ls
bld_sol_cmd      iota             obj              sol_bld
bld_sol_cmd_bak  lib              setupiota        tools
$ . ./setupiota
ROOT=/wmm_nbu/glili/IOTA_REp/1_iota


The IOTA build normally requires 3 steps:
Build on Solaris machine to generate all of the needed C++ files:
	bldsol&  /*run in background*/
	tailsol /*for checking the compilation log*/
Copy generated C++ files from sol_bld repo to the iota repo:
	bldrepo
Build on the Linux machine:
	bldlnx&
	taillnx	/*for checking the compilation log*/ 

If the build is successful the following file will be produced:
	obj/linux_x86/iota/opt/iota_prod.tgz

** install iota
cd /local/ltemme/iota/
scp ioannou@135.111.29.10:/wmm_nbu/ioannou/1_iota/obj/linux_x86/iota/opt/iota_prod.tgz .
mkdir iota_prod
cd iota_prod
tar -xzvf ../${PWD##*/}.tgz
cd ..
rm iota_latest
ln -s iota_prod iota_latest 

iota_latest is a link that points to the IOTA image that will be run.


** running iota
it separately:
cd /local/ltemme/iota/
mkdir test
cd test
scp -r ioannou@135.111.29.10:/wmm_nbu/ioannou/1_iota/iota/test/* .
cd msgtest
./runiota

runiota is the script that loads the configuration and starts IOTA. Within this script we can modify various flags (i.e. debug options). 
After the script runs, we get the iota prompt where we can give various commands and run tests.


** testing
>iota source 5gamf15test.tcl

If the test fails, we can check iota.log for debugging.
There is also a general test script that runs all the tests and should be run before each commit: r15msgtest

*** defined with set version and message type definition
runiota 201909 ###to test the set version one
lte10_201909.cfg ##config AMF use the corresponding protocol version
and source the file 5gamf15test.tcl
### in this case it will source 5gamf15_201909_test.tcl  instead

runiota ### test the orgininal version without version
source 5gamf15test.tcl


test/msgtest/5gamf15_201909_test.tcl  test/msgtest/5gamf_r15_201909_msgtmpl.tcl  test/msgtest/5gamf_r15_msgtmpl.tcl_bak
test/msgtest/5gamf15test.tcl          test/msgtest/5gamf_r15_msgtmpl.tcl



** iota framework msgd callback

*** calluri msgtype identification
through the http header: path and method(post)
0:25:07.452 N Message after decode:
        HTTP2 template

            BODY = -> HEADERSFRAME =
                FLAGS = $04
                STREAMID = $00000001
                HDRBLKFRAGMENT =

                    AUTHORITY = `2511:0:0:993::20:8080'
                    CONTENTTYPE = `application/json'
                    HDRTABLESZ = `4096'
                    METHOD = `POST'
                    PATH = `/nsmf-pdusession/v1/sm-contexts/smContextStatusUri'
                    SCHEME = `http'
10:25:07.452 N processHeaderFrame: Enter
10:25:07.452 N processHeaderFrame: connname=http2simhttp2sut
10:25:07.452 N processHeaderFrame: pathstr=/nsmf-pdusession/v1/sm-contexts/smContextStatusUri
10:25:07.452 N processHeaderFrame: pathlen=50
10:25:07.452 N processHeaderFrame: start=1
10:25:07.452 N processHeaderFrame: nftype = smf, stype = nsmf-pdusession-post.
10:25:07.452 N processHeaderFrame: start=17
10:25:07.452 N processHeaderFrame: start=20
10:25:07.452 N processHeaderFrame: start=32
10:25:07.452 N processHeaderFrame: no more slashes found
10:25:07.452 N processHeaderFrame: service found for: http2sim pathval: 16   ###how it get this 16? in previous sending the 
10:25:07.452 N processHeaderFrame: stype=nsmf-pdusession-post
10:25:07.452 N processHeaderFrame: code = 400
10:25:07.452 N processHeaderFrame: code = 403
10:25:07.452 N processHeaderFrame: code = 404
10:25:07.452 N processHeaderFrame: code = 411
10:25:07.452 N processHeaderFrame: code = 413
10:25:07.452 N processHeaderFrame: code = 415
10:25:07.452 N processHeaderFrame: code = 429
10:25:07.452 N processHeaderFrame: code = 500
10:25:07.452 N processHeaderFrame: code = 503
10:25:07.452 N processContentType: Enter
10:25:07.452 N getDefptr: connname=http2simhttp2sut
10:25:07.452 N processContentType: Enter
10:25:07.452 N getDefptr: connname=http2simhttp2sut
10:25:07.452 N processContentType: contenttype=application/json


10:25:07.452 N processHeaderFrame: HTTP2BLK streamiddata[http2simhttp2sut][1] =
         boundary = `EMPTY'
         contenttype = `json'
         nftype = `smf'
         sbamsg = `16'
         statusmsg = `
            400 = `19'
            403 = `19'
            404 = `19'
            411 = `19'
            413 = `19'
            415 = `19'
            429 = `19'
            500 = `19'
            503 = `19''
10:25:07.452 B [http2sim.http2rtr:(10.39.144.60:57865|19:1427)] http2sim.http2rtr sending message = HEADERSFRAME template


*** tie uri string and the msytpe
10:25:03.909 N SBASet::encodeField: p->name = SMCONTEXTSTATUSURI
10:25:03.909 N SBASet::encodeField: field.at(p->name) = http://testuri.uri/nsmf-pdusession/v1/sm-contexts/smContextStatusUri
10:25:03.909 N SBASet::encodeField: system[http2allieoptional] = off
10:25:03.909 N SBAString::encode
10:25:03.909 N fldlen = 68
10:25:03.909 N  fld encodedString
        offset     0  1  2  3  4  5  6  7    8  9  A  B  C  D  E  F   0123456789ABCDEF
        [00000]:  68 74 74 70 3a 2f 2f 74   65 73 74 75 72 69 2e 75   http://testuri.u
        [00010]:  72 69 2f 6e 73 6d 66 2d   70 64 75 73 65 73 73 69   ri/nsmf-pdusessi
        [00020]:  6f 6e 2f 76 31 2f 73 6d   2d 63 6f 6e 74 65 78 74   on/v1/sm-context
        [00030]:  73 2f 73 6d 43 6f 6e 74   65 78 74 53 74 61 74 75   s/smContextStatu
        [00040]:  73 55 72 69                                         sUri
10:25:03.909 N populateServiceDictionary, Json Callback String List = smf-post:16,400:19,403:19,404:19,411:19,413:19,415:19,429:19,500:19,503:19
10:25:03.909 N populateServiceDictionaryItem, Json Callback String = smf-post:16,400:19,403:19,404:19,411:19,413:19,415:19,429:19,500:19,503:19, callbackURI = http://testuri.uri/nsmf-pdusession/v1/sm-contexts/smContextStatusUri
10:25:03.909 N populateServiceDictionaryItem: networkFunction = smf, method = -post, suffix =
.......
10:25:07.368 N str2cmp = SMCONTEXTSTATUSURI
10:25:07.368 N SBAString::decode
10:25:07.368 N  SBAString::decode: Field data after decode
        offset     0  1  2  3  4  5  6  7    8  9  A  B  C  D  E  F   0123456789ABCDEF
        [00000]:  68 74 74 70 3a 2f 2f 74   65 73 74 75 72 69 2e 75   http://testuri.u
        [00010]:  72 69 2f 6e 73 6d 66 2d   70 64 75 73 65 73 73 69   ri/nsmf-pdusessi
        [00020]:  6f 6e 2f 76 31 2f 73 6d   2d 63 6f 6e 74 65 78 74   on/v1/sm-context
        [00030]:  73 2f 73 6d 43 6f 6e 74   65 78 74 53 74 61 74 75   s/smContextStatu
        [00040]:  73 55 72 69                                         sUri
10:25:07.368 N populateServiceDictionary, Json Callback String List = smf-post:16,400:19,403:19,404:19,411:19,413:19,415:19,429:19,500:19,503:19
10:25:07.368 N populateServiceDictionaryItem, Json Callback String = smf-post:16,400:19,403:19,404:19,411:19,413:19,415:19,429:19,500:19,503:19, callbackURI = http://testuri.uri/nsmf-pdusession/v1/sm-contexts/smContextStatusUri
###call back uri should be /nsmf-pdusession/v1/sm-contexts/smContextStatusUri, only path name matters, it will restore the pathstr,
### the next time, when it receive the header stream this exact same pathstr, it will use 16 to decode " service found for: http2sut pathval: 16"
10:25:07.368 N populateServiceDictionaryItem: networkFunction = smf, method = -post, suffix =


** iota system.sdt sytem dictionary for http2 msgtype
08:35:26.812 N processHeaderFrame: connname=http2suthttp2sim
08:35:26.812 N processHeaderFrame: pathstr=/nsmf-pdusession/v1/sm-contexts
08:35:26.812 N processHeaderFrame: pathlen=31
08:35:26.812 N processHeaderFrame: start=1
08:35:26.812 N processHeaderFrame: nftype = smf, stype = nsmf-pdusession-post.
08:35:26.812 N processHeaderFrame: start=17
08:35:26.812 N processHeaderFrame: start=20
08:35:26.812 N processHeaderFrame: no more slashes found
08:35:26.813 N processHeaderFrame: service found for: http2sut pathval: 1
08:35:26.813 N processHeaderFrame: stype=nsmf-pdusession-post
08:35:26.813 N processHeaderFrame: code = 201
08:35:26.813 N processHeaderFrame: code = 400
08:35:26.813 N processHeaderFrame: code = 403
08:35:26.813 N processHeaderFrame: code = 404
08:35:26.813 N processHeaderFrame: code = 411
08:35:26.813 N processHeaderFrame: code = 413
08:35:26.813 N processHeaderFrame: code = 415
08:35:26.813 N processHeaderFrame: code = 429
08:35:26.813 N processHeaderFrame: code = 500
08:35:26.813 N processHeaderFrame: code = 503
08:35:26.813 N processHeaderFrame: code = 504
08:35:26.813 N processContentType: Enter
08:35:26.813 N getDefptr: connname=http2suthttp2sim
08:35:26.813 N processContentType: contenttype=application/json
08:35:26.813 N processHeaderFrame: HTTP2BLK streamiddata[http2suthttp2sim][1] =
         boundary = `EMPTY'
         contenttype = `json'
         nftype = `smf'
         sbamsg = `1'   ####servicetype[nsmf-pdusession-post][v1][sm-contexts][reqmsg],   ReadWrite,      1       //createsmcontextreq 
         statusmsg = `     ####servicetype[nsmf-pdusession-post][v1][sm-contexts][statusmsg][201],                     ReadWrite,      2       //createsmcontextrsp
                           ###servicetype[nsmf-pdusession-post][v1][sm-contexts][statusmsg][400],                     ReadWrite,      3       //createsmcontextfailrsp
                           ###servicetype[nsmf-pdusession-post][v1][sm-contexts][statusmsg][403],                     ReadWrite,      3       //createsmcontextfailrsp
servicetype[nsmf-pdusession-post][v1][sm-contexts][statusmsg][404],                     ReadWrite,      3       //createsmcontextfailrsp
servicetype[nsmf-pdusession-post][v1][sm-contexts][statusmsg][411],                     ReadWrite,      19      //problemdetailsrsp
servicetype[nsmf-pdusession-post][v1][sm-contexts][statusmsg][413],                     ReadWrite,      19      //problemdetailsrsp
servicetype[nsmf-pdusession-post][v1][sm-contexts][statusmsg][415],                     ReadWrite,      19      //problemdetailsrsp
servicetype[nsmf-pdusession-post][v1][sm-contexts][statusmsg][429],                     ReadWrite,      19      //problemdetailsrsp
servicetype[nsmf-pdusession-post][v1][sm-contexts][statusmsg][500],                     ReadWrite,      3       //createsmcontextfailrsp
servicetype[nsmf-pdusession-post][v1][sm-contexts][statusmsg][503],                     ReadWrite,      3       //createsmcontextfailrsp
servicetype[nsmf-pdusession-post][v1][sm-contexts][statusmsg][504],                     ReadWrite,      3       //createsmcontextfailrsp

            201 = `2'
            400 = `3'
            403 = `3'
            404 = `3'
            411 = `19'
            413 = `19'
            415 = `19'
            429 = `19'
            500 = `3'
            503 = `3'
            504 = `3''
08:35:26.813 N encodeHdrBlkFrag
08:35:26.813 N header name AUTHORITY found in http2headers in http2blk.sdt
08:35:26.813 N header name CONTENTTYPE found in http2headers in http2blk.sdt
08:35:26.813 N header name METHOD found in http2headers in http2blk.sdt
08:35:26.813 N header name PATH found in http2headers in http2blk.sdt
08:35:26.813 N header name SCHEME found in http2headers in http2blk.sdt
08:35:26.813 N encodeHdrBlkFrag - nvlen = 5
08:35:26.813 N  hdrtblszval:
        offset     0  1  2  3  4  5  6  7    8  9  A  B  C  D  E  F   0123456789ABCDEF
        [00000]:  3f e1 1f                                            ?..
08:35:26.814 N hdrtblbytes: 3
08:35:26.814 N authname: :authority, length = 10
08:35:26.814 N authvalstr: 2511:0:0:993::20:8080, length = 21
08:35:26.814 N  authval:
        offset     0  1  2  3  4  5  6  7    8  9  A  B  C  D  E  F   0123456789ABCDEF
        [00000]:  32 35 31 31 3a 30 3a 30   3a 39 39 33 3a 3a 32 30   2511:0:0:993::20
        [00010]:  3a 38 30 38 30                                      :8080
08:35:26.814 N methname: :method, length = 7
08:35:26.814 N methvalstr: POST, length = 4
08:35:26.814 N  methval:
        offset     0  1  2  3  4  5  6  7    8  9  A  B  C  D  E  F   0123456789ABCDEF
        [00000]:  50 4f 53 54                                         POST
08:35:26.814 N pathname: :path, length = 5
08:35:26.814 N pathvalstr: /nsmf-pdusession/v1/sm-contexts, length = 31
08:35:26.814 N  pathval:
        offset     0  1  2  3  4  5  6  7    8  9  A  B  C  D  E  F   0123456789ABCDEF
        [00000]:  2f 6e 73 6d 66 2d 70 64   75 73 65 73 73 69 6f 6e   /nsmf-pdusession
        [00010]:  2f 76 31 2f 73 6d 2d 63   6f 6e 74 65 78 74 73      /v1/sm-contexts
08:35:26.814 N schemename: :scheme, length = 7


** iota encoding/decoding
*** iota encoding hexstring 
05:29:48.925 M  Sending a message from IOTA
        offset     0  1  2  3  4  5  6  7    8  9  A  B  C  D  E  F   0123456789ABCDEF
        [00000]:  00 00 4b 01 04 00 00 00   01 3f e1 1f 41 90 13 61   ..K......?..A..a
        [00010]:  0d c0 5c 05 c7 df 66 e5   c1 02 e3 c0 78 1f 42 83   ..\...f.....x.B.
        [00020]:  ac e8 4f 04 a1 62 a1 d3   2a c4 3d 34 b1 dc 2c 5a   ..O..b..*.=4..,Z
        [00030]:  55 88 7a 92 5f 29 43 16   96 f1 ea 49 7c a7 24 8c   U.z._)C....I|.$.
        [00040]:  26 c1 d4 89 4b 67 86 5f   8b 1d 75 d0 62 0d 26 3d   &...Kg._..u.b.&=
        [00050]:  4c 74 41 ea                                         LtA.

*** iota sending message template
template will be the same as definition of HDRBLKFRAGMENT
06:03:01.921 B [http2sut.http2rtr:(10.39.144.60:59247|19:1431)] http2sut.http2rtr sending message = HTTP2 template

            BODY = -> HEADERSFRAME =
                FLAGS = 4
                STREAMID = 1
                HDRBLKFRAGMENT =

                    ACCEPT = `EMPTY'
                    AUTHORITY = `2511:0:0:993::20:8080'
                    CACHECONTROL = `EMPTY'
                    CONTENTID = `EMPTY'
                    CONTENTLEN = `EMPTY'
                    CONTENTTYPE = `application/json'
                    DATE = `EMPTY'
                    ETAG = `EMPTY'
                    HDRTABLESZ = `4096'
                    IFNONEMATCH = `EMPTY'
                    LINK = `EMPTY'
                    LOCATION = `EMPTY'
                    METHOD = `post'
                    PATH = `/namf-comm/v1/ue-contexts/ueContextId/transfer'
                    RETRYAFTER = `EMPTY'
                    SCHEME = `EMPTY'
                    STATUS = `EMPTY'
                    USERAGENT = `EMPTY'
--------------------------------------------------------------------------------------------------------------------
message template for sending:
db loadTemplate {define amf_create_ue_context_transfer_hdrframe_req_test {
HTTP2MSG {
   {BODY {@HEADERSFRAME {
         {FLAGS 4}
         {STREAMID 1}
         {HDRBLKFRAGMENT {
            {HDRTABLESZ 4096}
            {METHOD "post"}
            {AUTHORITY "2511:0:0:993::20:8080"}
            {PATH "/namf-comm/v1/ue-contexts/ueContextId/transfer"}
            {CONTENTTYPE %contenttype}
         }}
   }}}
}
}}

*** iota receiving message
5:29:48.926 M [http2sim-mmes-0:(10.39.144.60:46227|20:1549)] http2sim-mmes-0 received message
        0000  00 00 4b 01 04 00 00 00 01 3f e1 1f 41 90 13 61  ..K......?..A..a
        0016  0d c0 5c 05 c7 df 66 e5 c1 02 e3 c0 78 1f 42 83  ..\...f.....x.B.
        0032  ac e8 4f 04 a1 62 a1 d3 2a c4 3d 34 b1 dc 2c 5a  ..O..b..*.=4..,Z
        0048  55 88 7a 92 5f 29 43 16 96 f1 ea 49 7c a7 24 8c  U.z._)C....I|.$.
        0064  26 c1 d4 89 4b 67 86 5f 8b 1d 75 d0 62 0d 26 3d  &...Kg._..u.b.&=
        0080  4c 74 41 ea                                      LtA.


*** iota receiving headerframe
**** iota decoding header frame 
06:03:01.924 N decodeHdrBlkFrag - hdrlen - hdridx 71
06:03:01.924 N hdrnamestr = :authority
06:03:01.924 N hdrvalstr = "2511:0:0:993::20:8080"
06:03:01.924 N hdrnamestr = :method
06:03:01.924 N hdrvalstr = "post"
06:03:01.924 N hdrnamestr = :path
06:03:01.924 N hdrvalstr = "/namf-comm/v1/ue-contexts/ueContextId/transfer"
06:03:01.924 N hdrnamestr = content-type
06:03:01.924 N hdrvalstr = "application/json"
06:03:01.924 N hdrField =

            AUTHORITY = `2511:0:0:993::20:8080'
            CONTENTTYPE = `application/json'
            HDRTABLESZ = `4096'
            METHOD = `post'
            PATH = `/namf-comm/v1/ue-contexts/ueContextId/transfer'
06:03:01.924 N Message after decode:
        HTTP2 template

            BODY = -> HEADERSFRAME =
                FLAGS = $04
                STREAMID = $00000001
                HDRBLKFRAGMENT =

                    AUTHORITY = `2511:0:0:993::20:8080'
                    CONTENTTYPE = `application/json'
                    HDRTABLESZ = `4096'
                    METHOD = `post'
                    PATH = `/namf-comm/v1/ue-contexts/ueContextId/transfer'
06:03:01.924 N processHeaderFrame: Enter
06:03:01.924 N processHeaderFrame: connname=http2simhttp2sut


**** match this header with real data messagetype
6:03:01.925 N processHeaderFrame: HTTP2BLK streamiddata[http2simhttp2sut][1] =
         boundary = `EMPTY'
         contenttype = `json'
         nftype = `amf'
         sbamsg = `1'    ##### this is the real message type
         statusmsg = `
            200 = `2'
            400 = `3'
            403 = `3'
            411 = `3'
            413 = `3'
            415 = `3'
            429 = `3'
            500 = `3'
            503 = `3''
06:03:01.925 B [http2sim.http2rtr:(10.39.144.60:59247|19:1423)] http2sim.http2rtr sending message = HEADERSFRAME template

            BODY = -> HEADERSFRAME =
                FLAGS = $04
                STREAMID = $00000001
                HDRBLKFRAGMENT =

                    AUTHORITY = `2511:0:0:993::20:8080'
                    CONTENTTYPE = `application/json'
                    HDRTABLESZ = `4096'
                    METHOD = `post'
                    PATH = `/namf-comm/v1/ue-contexts/ueContextId/transfer'
        from PID= 1423(http2sim::http2rtr) to PID=1517


**** message template mismatch
06:16:49.750 U >>>>>> LAST RECV MESSAGE TEMPLATE: amf_create_ue_context_transfer_hdrframe_req_test
06:16:49.751 U @@@@@@@@@@@@@@@@@@
06:16:49.751 U HTTP2MSG {
           {BODY {@HEADERSFRAME {
                 {FLAGS 4}
                 {STREAMID 1}
                 {HDRBLKFRAGMENT {
                    {HDRTABLESZ 4096}
                    {METHOD "post"}
                    {AUTHORITY "2511:0:0:993::20:8080"}
                    {PATH "/namf-comm/v1/ue-contexts/ueContextId/transfer"}
                    {SCHEME "http" }
                    {CONTENTTYPE %contenttype}
                 }}
           }}}
        }

06:16:49.751 U @@@@@@@@@@@@@@@@@@

06:16:49.751 U rcvd msg: HTTP2 template

            BODY = -> HEADERSFRAME =
                FLAGS = $04
                STREAMID = $00000001
                HDRBLKFRAGMENT =

                    AUTHORITY = `2511:0:0:993::20:8080'
                    CONTENTTYPE = `application/json'
                    HDRTABLESZ = `4096'
                    METHOD = `post'
                    PATH = `/namf-comm/v1/ue-contexts/ueContextId/transfer'
06:16:49.751 F Error: "ERROR: missing IE HTTP2MSG.BODY.@HEADERSFRAME.HDRBLKFRAGMENT.SCHEME. "


--------------
receiving template:
db loadTemplate {define amf_create_ue_context_transfer_hdrframe_req_test {                
HTTP2MSG {                                                                                
   {BODY {@HEADERSFRAME {                                                                 
         {FLAGS 4}                                                                        
         {STREAMID 1}                                                                     
         {HDRBLKFRAGMENT {                                                                
            {HDRTABLESZ 4096}                                                             
            {METHOD "post"}                                                               
            {AUTHORITY "2511:0:0:993::20:8080"}                                           
            {PATH "/namf-comm/v1/ue-contexts/ueContextId/transfer"}                       
            {SCHEME "http" }                                                              
            {CONTENTTYPE %contenttype}                                                    
         }}                                                                               
   }}}                                                                                    
}                                                                                         
}}                                                                                        
                                                                                          

***** for opiontal field receiving template

receiving template:
db loadTemplate {define amf_create_ue_context_transfer_hdrframe_req_test {                
HTTP2MSG {                                                                                
   {BODY {@HEADERSFRAME {                                                                 
         {FLAGS 4}                                                                        
         {STREAMID 1}                                                                     
         {HDRBLKFRAGMENT {                                                                
            {HDRTABLESZ 4096}                                                             
            {METHOD "post"}                                                               
            {AUTHORITY "2511:0:0:993::20:8080"}                                           
            {PATH "/namf-comm/v1/ue-contexts/ueContextId/transfer"}                       
            {SCHEME "http" |EMPTY }    //make this optional, then it will be OK                                                             
            {CONTENTTYPE %contenttype}                                                    
         }}                                                                               
   }}}                                                                                    
}                                                                                         
}}                                                                                        
 

*** uri 
10:20:10.695 N processHeaderFrame: service NOT found for vsmfPduSessionUri[reqmsg] in servicedictionary
         modify = `
            reqmsg = `23'
            statusmsg = `
                200 = `24'
                400 = `25'
                403 = `25'
                404 = `25'
                411 = `19'
                413 = `19'
                415 = `19'
                429 = `19'
                500 = `25'
                503 = `25'''
         release = `
            reqmsg = `26'
            statusmsg = `
                400 = `19'
                403 = `19'
                404 = `19'
                411 = `19'
                413 = `19'
                415 = `19'
                429 = `19'
                500 = `19'
                503 = `19'''
10:20:10.695 N processHeaderFrame: stype=nsmf-pdusession
10:20:10.695 N processHeaderFrame: Use old dictionary to populate rsp codes for path /nsmf-pdusession/v1/pdu-sessions/vsmfPduSessionUri
10:20:10.695 N processHeaderFrame: DEFAULT service found for: http2sim servicetype.nsmf-pdusession-post.4 16
10:20:10.695 N processContentType: Enter
10:20:10.695 N getDefptr: connname=http2simhttp2sut
10:20:10.695 N processContentType: contenttype=application/json
10:20:10.695 N processHeaderFrame: HTTP2BLK streamiddata[http2simhttp2sut][1] =
         boundary = `EMPTY'
         contenttype = `json'
         nftype = `smf'
         sbamsg = `16'


* iota and Robot case
Current installed IOTA version: 'iota_prod'
Required IOTA Version: 'iota_v3_tag0118'
Downloading and installing IOTA: 'iota_v3_tag0118'
Configuring the IOTA Simulator

** get iota version the testcase wanted in IOTA.py
   def _wanted_iotaver(self):
    |   ver = os.getenv('IOTA_VERSION')
    |   if not ver:
    |   |   application = self.sysInfo_application('application')
    |   |   logger.info('cmm systemInfo show - application = {}'.format(application))
    |   |   releaseNum = self.sysInfo_application('releaseNum')
    |   |   logger.info('cmm systemInfo show - releaseNum = {}'.format(releaseNum))
    |   |   # example: releaseNum = "20.0.0"  for CMM20.0.0 project
    |   |   if application.lower() == 'amf':
    |   |   |   if releaseNum == '20.0.2_example':


** invoking iota procedure asynchronizedly
*** start iota procedure async (execute next robot clause immediately, not waiting for it complete)
Iota Async Procedure Start 5gNgAmfConfigurationUpdate, -N2LinkCount ${totalN2Links} 
### invoking an iota procedure then return imediately for the next robot clause execution
def iota_async_procedure_start(self, *cmdstrings, **configuration):
        """ start executing an IOTA procedure but dont wait for for it to complete """
        self._async_verifystring = configuration.get('verifystring', 'IOTAPROCRETCODE=0')
        self._async_timeout = configuration.get('timeout', '180')
        cmdstring = ' '.join(cmdstrings)

        if self._thread is None:
            if self._tn_connected is False:
                try:
                    self._connect()
                except Exception as ex:
                    raise AssertionError('Failed to connect to IOTA via telnet:', ex)
            logger.info('Executing async procedure: ' + cmdstring)
            self._tn.write(cmdstring)
            self._thread = IotaOutputReader(self._tn, self._queue, self._async_timeout)
            self._thread.daemon = True
            self._thread.start()
        else:
            raise AssertionError('There is already an IOTA async procedure running.')


*** iota async procedure wait for completion
    def iota_async_procedure_wait_for_completion(self):
        """wait until current IOTA procedure completes, then return all output.        """

        while self.iota_async_procedure_still_running():
            time.sleep(0.2)
        self._thread = None
        output = self._get_messages()
        if self._async_verifystring not in output:
            logger.error(output)
            raise AssertionError('Did not get expected response from IOTA "{}"'.format(self._async_verifystring))
        return output

 

*** 5g iota case only to preparing iota server for later interactive useage (telnet 0 2121)
file 5ginitializeIotaFlex.robot
--------------------------------------------------------------
*** Settings ***
Metadata          NETWORKMODE    ${CMM.NETWORKMODE}
Resource          iota.txt
Force Tags        owner_kamal.fernando    tc_prio_1
Suite Setup       Connect To IOTA        ${IOTA_CONFIG['host']}

*** Variables ***

*** Test Cases ***
5ginitializeIotaflex
    [Tags]     tech_5g    init
    [Documentation]   Restart IOTA and configure for 5g test cases
    Terminate IOTA
    sleep    1
    AMF IOTA Suite Setup
#    Gnb NGSETUP
-------------------------------------------------------------------

**** give wrong addr to make the nssetup request failing
### ###
if give the wrong amf ip address for GNB, then the case will failed here, since no response for this request.
========
b/testers/cmm/testcases-iota/config/ate_data.py
@@ -493,7 +493,8 @@ CMM = {
     'M3UA9MHB_V6_1': '2511:0:0:' + v6_vsr_segment + ':0:0:0:249',

     # Single-home local AMF Service IPv4 addresses on IPDS
-    'N2_V4': '172.' + v4_vsr_octet + '.46.201',
+    #'N2_V4': '172.' + v4_vsr_octet + '.46.201',
+    'N2_V4': '14.100.0.247',
-----------------------------------------------------------------


**** run an iota case to make the iota env ready to input iota pro  


KEYWORD  iota . AMF IOTA Suite Setup  

00:03:18.909 KEYWORD  iota . Verify IOTA Is Running  
00:00:00.356 KEYWORD ${running} = IOTALib . Is Iota Running ${IOTA_CONFIG['host']} 
00:03:18.553 KEYWORD  iota . IOTA Suite Setup  
00:03:18.553 KEYWORD  iotabase . Restart IOTA  
00:00:00.533 KEYWORD  IOTALib . Terminate Iota  
00:00:02.997 KEYWORD  iotabase . IOTA DNS Provision  
00:00:30.882 KEYWORD  iotabase . Setup IOTA Test System  
00:00:10.261 KEYWORD  iotadnslib . Create Default DNS Records  
00:01:01.854 KEYWORD  IOTALib . Start Iota RESTART 
00:01:32.026 KEYWORD  NEC_Conf_Resource . NEC Configure IOTA Simulator  

00:01:32.026 KEYWORD  iotabase . Configure IOTA AMF Simulator  

00:00:01.180 KEYWORD  iotabase . CommonIotaCommand CreateGUMMEI -plmnname plmn01 -mcc ${CMM['MCC']} -mnc ${CMM['MNC']} -cc 001 -ndc 050 -mmegi ${CMM['MME_GRPID']} -mmec ${CMM['MME_CODE']} 
00:00:00.371 KEYWORD  iotabase . CommonIotaCommand CreateUE -name ue1 -imsi ${IOTA['IMSI1']} -imei 1234567890123456 
00:00:00.377 KEYWORD  iotabase . CommonIotaCommand CreateHTTP2Server -name ausf1_s -ip ${IOTA['AUSF1_V4']} -port ${CMM['HTTP_PORT']} -amfip ${CMM['N12_V4']} -delay 5000 
00:00:00.980 KEYWORD ${isMultiHome} = iotabase . Is IOTA MultiHome AMF Configuration  

KEYWORD ${isMultiHome} = iotabase . Is IOTA MultiHome AMF Configuration  
00:00:00.000 KEYWORD  BuiltIn . Set Suite Variable ${isMultiHome} 
00:00:02.392 KEYWORD ${isDualstack} = iotabase . Is IOTA Dualstack AMF Configuration  
00:00:11.249 KEYWORD  BuiltIn . Run Keyword If ${isDualstack}, Add IOTA AMF V6 Simulators 
00:00:00.000 KEYWORD  BuiltIn . Run Keyword If ${isMultiHome}, Configure MultiHome AMF IOTA gNB 
00:00:09.750 KEYWORD  BuiltIn . Run Keyword Unless ${isMultiHome}, Configure SingleHome AMF IOTA gNB 
00:00:04.409 KEYWORD  IOTALib . Iota Script base/iota_files/5g_stateMachines.tcl 
00:00:06.612 KEYWORD  IOTALib . Iota Script base/iota_files/5g_IOTAinterfaceProcedures.tcl 
00:00:05.019 KEYWORD  IOTALib . Iota Script base/iota_files/5g_messageTemplates.tcl 
00:00:03.539 KEYWORD  IOTALib . Iota Script base/iota_files/5g_postInitProcs.tcl 
00:00:30.168 KEYWORD  iotabase . Gnb NGSETUP  
00:00:30.168 KEYWORD  IOTALib . Iota Procedure 5gNgSetup, -ta1 ${IOTA.AMF_TAC0}:${CMM.MCC}${CMM.MNC}:01,02,03:D143A5,D143A5,D143A5 -gNB gnb01 -gnbname gnb01 -postinitproc {::ngSetupRetry} 
10:24:20.511 TRACE Arguments: [ '5gNgSetup' | '-ta1 30000:46002:01,02,03:D143A5,D143A5,D143A5 -gNB gnb01 -gnbname gnb01 -postinitproc {::ngSetupRetry}' ] 
Sending IOTA procedure: "5gNgSetup -ta1 30000:46002:01,02,03:D143A5,D143A5,D143A5 

***** GNB sctp connection estblished

KEYWORD  BuiltIn . Run Keyword Unless ${isMultiHome}, Configure SingleHome AMF IOTA gNB 
00:00:00.379 KEYWORD  iotabase . CommonIotaCommand CreateGNB -name gnb01 -id 05151 -gnbip ${IOTA['5GNB1_V4']} -gnbport ${CMM['N2_PORT']} -amfip ${CMM['N2_V4']} -amfport ${CMM['N2_PORT']} -delay 5000 -plmn plmn01 -ta ${IOTA['AMF_TAC0']} -ngsetup false 
00:00:00.379 KEYWORD  IOTALib . Iota Command ${cmdstring} 

**** iota command 

CreateGNB -name gnb16 -id 05154 -gnbip 172.16.59.11 -gnbport 38412 -amfip 10.10.20.9 -amfport 38412 -delay 5000 -plmn plmn01 -ta 788 -ngsetup false
5gNgSetup -ta1 788 -gNB gnb16 -gnbname gnb16 -verbose 3


tools:
home dir：
/ww/kaml
compiler/asn1/asn1cpp.py
genbytes  


* iota and jenkins
/var/lib/jenkins  
jobs in this dir
~/.../workspace for iota case running




* iota and procedures to use
** attach 4g, 4gto 3g rau then 3gto4g tau
TEST ite010 inter sys TAU with SGW reloc no PRA report afer PRA action stop
Full Name:	F10904-11 Dc Pra Ite Regression.ite010 inter sys TAU with SGW reloc no PRA report afer PRA action stop
 Iota Script base/iota_files/messageTemplates.tcl
 Iota Procedure 4gAttachImsi -imsi ${IOTA.IMSI4} -epsattachtype 2 -verbose 1
 Iota Procedure 4gToExternalSgsnRauS3 -sndclr false -sgsdetach true -verbose 1
 Iota Procedure 4gTauFromExternalSgsnS3 -active true -verbose 1, -postinitproc {set ::c_ue(Bld_contextrsp_s3_pdncon1_presrptareaaction), [::bld_mAct_PRA_IE {{-action start -praid ${PRAID_8388610}}}];, set ::c_ue(Bld_csrsp_tgt_presrptareaaction), [::bld_mAct_PRA_IE {{-action stop -praid ${PRAID_8388610}}}];, ::ctxsetuprsp ${GNB6000_1_IP};, ::vfy_pra_ie -msg mbreq -multi_pra "${PRAID_8388610}:empty"}
 Iota Procedure 4gDetach
 Iota Procedure 4gCancelLocation


** iota get coredump files in ate env
/usr/tmp/getiotastack to get core dump files
in the directory, open the dump file
wisebridge could be ingroed

* iota development
** iota update 5G message
*** iota message definition
------------------------------
set:updatesmcontextreq
begin
           ### field is upper case of the jsonname for encoding/decoding
        CPCIOTENABLED          :        CpCiotEnabledBool      -O

---------------------------------------------------------------------------------


-----------------------------------------
field:CpCiotEnabledBool
  set desc "cpCiot Enabled"
  set jsontype "boolean"
  set jsonname "cpCiotEnabled"  ### json name defined in yaml property
  set class "SBABoolean"
end
----------------------------



**** iota test message
encoding message:
----------------------------
 [01440]:  33 22 2c 20 22 63 70 43   69 6f 74 45 6e 61 62 6c   3", "cpCiotEnabl
 [01450]:  65 64 22 3a 20 66 61 6c   73 65 2c 20 22 63 70 4f   ed": false, "cpO
----------------------------------

in message template:
   {CPCIOTENABLED false}

*** iota message multiple definition
in *.msgd file, if you define a jsonname named SESSIONID, and other files alreay define it, you should set it in ignoreSymbols, or the linking to libEps.so library will fail
set ignoreSymbols { BODY SESSIONID

this could be detected here:
+ /umts6/atca/RHEL6.Xlcp/cross_120302/Xgcc/xgcc-i386/bin/i386-redhat-linux-g++ libEps.so.objfiles -fPIC -shared -Wl -L. -L/umts6/atca/RHEL6.Xlcp/ver_180104/product_loc/rpms_only/xgcc-i386/usr/lib -o ../../../../../../../obj/linux_x86/iota/opt/lib/libEps.so
/wmm_nbu/glili/IOTA_REp/1_iota/obj/linux_x86/iota/ctpapp/lte/eps/linux_x86_iota_ctpapp_lte_eps5/NsmfMsgs.o: In function `Nsmf':
/wmm_nbu/glili/IOTA_REp/1_iota/obj/linux_x86/iota/ctpapp/lte/eps/linux_x86_iota_ctpapp_lte_eps5/../../../../../../../obj/linux_x86/iota/ctpapp/lte/eps/msg/NsmfMsgs.C:25: multiple definition of `CPONLYIND'
/wmm_nbu/glili/IOTA_REp/1_iota/obj/linux_x86/iota/ctpapp/lte/eps/linux_x86_iota_ctpapp_lte_eps2/ENasMsgSyms.o:/wmm_nbu/glili/IOTA_REp/1_iota/obj/linux_x86/iota/ctpapp/lte/eps/linux_x86_iota_ctpapp_lte_eps2/../../../../../../../obj/linux_x86/iota/ctpapp/lte/eps/msg/ENasMsgSyms.C:5: first defined here
/wmm_nbu/glili/IOTA_REp/1_iota/obj/linux_x86/iota/ctpapp/lte/eps/linux_x86_iota_ctpapp_lte_eps5/NamfMsgs.o: In function `Namf':
/wmm_nbu/glili/IOTA_REp/1_iota/obj/linux_x86/iota/ctpapp/lte/eps/linux_x86_iota_ctpapp_lte_eps5/../../../../../../../obj/linux_x86/iota/ctpapp/lte/eps/msg/NamfMsgs.C:23: multiple definition of `NID'
/wmm_nbu/glili/IOTA_REp/1_iota/obj/linux_x86/iota/ctpapp/lte/eps/linux_x86_iota_ctpapp_lte_eps5/NsmfMsgs.o:/wmm_nbu/glili/IOTA_REp/1_iota/obj/linux_x86/iota/ctpapp/lte/eps/linux_x86_iota_ctpapp_lte_eps5/../../../../../../../iota/ctpapp/lte/wiseiota/hdr/ValInline.h:525: first defined here
collect2: ld returned 1 exit status
make: *** exit code 1 making ../../../../../../../obj/linux_x86/iota/opt/lib/libEps.so



*** iota syntax error 
wmm-iotarh6x32::1_iota:/wmm_nbu/glili/IOTA_REp/1_iota $ 
obj/linux_x86/iota/opt/bin/gpdc iota/./ctpapp/lte/eps/msg/nsmf.msgd -g gtpv1


** iota sbi (5G) message encode/decode
*** how to test message encoding/decoding
there are two parts, first one is headerframe, the second one is dataframe
sut receive message for decoding, first, it receive headerframe, then it receive dataframe

test.tcl:
------------------------------------------------------
send http2sut -> http2sim -msg pdu_session_notify_hdrframe_req -mapping ::c_ue
recv http2sut -> http2sim -type HEADERSFRAME -msg pdu_session_notify_hdrframe_req -mapping ::c_ue

send http2sut -> http2sim -msg pdu_session_notify_dataframe_req -mapping ::c_ue
recv http2sut -> http2sim -type DATAFRAME -msg pdu_session_notify_dataframe_req -mapping ::c_ue
-----------------------------------------------------

***  iota command prompt
when source test.tcl
-------------------------------------------------------------------------------
+++
HTTP2 {{BODY {@HEADERSFRAME {{FLAGS 4} {HDRBLKFRAGMENT {{AUTHORITY "2511:0:0:993::20:8080"} {CONTENTTYPE application/json} {HDRTABLESZ 4096} {METHOD POST} {PATH /nsmf-pdusession/v1/pdu-sessions/vsmfPduSessionUri} {SCHEME http}}} {STREAMID 1}}}} {localName http2sut} {remoteName http2sim}}

>>>>>> SEND MESSAGE TEMPLATE: pdu_session_notify_hdrframe_req
processHeaderFrame: service NOT found using precise method. Try again, but prefer _var_ over precise.
processHeaderFrame: Resource NOT found for [vsmfPduSessionUri][reqmsg] in service dictionary.
processHeaderFrame: Use old dictionary to populate rsp codes for path /nsmf-pdusession/v1/pdu-sessions/vsmfPduSessionUriprocessHeaderFrame: DEFAULT service found for: http2sut servicetype.nsmf-pdusession-post.4 16
processHeaderFrame: service NOT found using precise method. Try again, but prefer _var_ over precise.
processHeaderFrame: Resource NOT found for [vsmfPduSessionUri][reqmsg] in service dictionary.
processHeaderFrame: Use old dictionary to populate rsp codes for path /nsmf-pdusession/v1/pdu-sessions/vsmfPduSessionUriprocessHeaderFrame: DEFAULT service found for: http2sim servicetype.nsmf-pdusession-post.4 16
+++
HTTP2 {{BODY {@HEADERSFRAME {{FLAGS $04} {HDRBLKFRAGMENT {{AUTHORITY "2511:0:0:993::20:8080"} {CONTENTTYPE application/json} {HDRTABLESZ 4096} {METHOD POST} {PATH /nsmf-pdusession/v1/pdu-sessions/vsmfPduSessionUri} {SCHEME http}}} {STREAMID $00000001}}}} {localName http2sim} {remoteName http2sut}}


http2sut ---- HEADERSFRAME ---> http2sim
>>>>>> RECV MESSAGE TEMPLATE: pdu_session_notify_hdrframe_req
http2sim <--- DATAFRAME(PDUSESSIONSTATUSNOTIFY) ---- http2sut

*** iota encoding/decoding mechanism
headerframe request
-----------------------
  BODY = -> HEADERSFRAME =
                FLAGS = $04
                STREAMID = $00000001
                HDRBLKFRAGMENT =

                    AUTHORITY = `2511:0:0:993::20:8080'
                    CONTENTTYPE = `application/json'
                    HDRTABLESZ = `4096'
                    METHOD = `POST' #### this is req message
                    PATH = `/nsmf-pdusession/v1/pdu-sessions'
                    SCHEME = `http'
--------------------------------------------------------
servicetype[nsmf-pdusession-post][v1][pdu-sessions][reqmsg],                            ReadWrite,      20      //pdusessioncreatereq

**** headerframe request info retrieving

when decode an iota dataframe message, how do you know which message is this?
after decoding a headerframe message, PATH field will be saved as pathstr, and get ResourceURI, then it will look up systemservice diciontary to get sbamsg number
get sbamsg number, that's the next dataframe message type. statusmsg is the reply dataframe message
after decoding headerframe request
=================================
22:18:59.600 N processHeaderFrame: Enter
22:18:59.600 N processHeaderFrame: connname=http2simhttp2sut
22:18:59.600 N processHeaderFrame: pathstr=/nsmf-pdusession/v1/pdu-sessions
22:18:59.600 N processHeaderFrame: pathlen=32
22:18:59.600 N processHeaderFrame: ResourceURI: [/nsmf-pdusession/v1/pdu-sessions], apistart=0.
22:18:59.601 N processHeaderFrame: nftype = smf, stype = nsmf-pdusession-postservicename = nsmf-pdusession.
22:18:59.601 N processContentType: Enter
22:18:59.602 N getDefptr: connname=http2simhttp2sut
22:18:59.602 N processContentType: contenttype=application/json
22:18:59.602 N processHeaderFrame: HTTP2BLK streamiddata[http2simhttp2sut][1] =
         boundary = `EMPTY'
         contenttype = `json'
         nftype = `smf'
         sbamsg = `20'  #### the next receiving dataframe's message type after this headerframe
#### servicetype[nsmf-pdusession-post][v1][pdu-sessions][reqmsg],                            ReadWrite,      20      //pdusessioncreatereq

         servicename = `nsmf-pdusession'
         statusmsg = `
            201 = `21'
            307 = `19'
            400 = `22'
            401 = `19'
            403 = `22'
            404 = `22'
            411 = `19'
            413 = `19'
            415 = `19'
            429 = `19'
            500 = `22'
            503 = `22''
----------------------------------------------------


**** dataframe request message
***** encoding dataframe 
after encoding all body message:     enc_bytes is the keyword
N enc_bytes = { "supi": "imsi-310012601000000", "unauthenticatedSupi": false, "pei": "imei-123456789012345", "pduSessionId": 1, "dnn": "TESTDNN", "selecteddnn": "TESTDNN", "sNssai": { "sst": 1, "sd": "010203" }

***** decoding dataframe 
bytestr is the keyword for start decoding dataframe
----------------------------------------------------------------
N Http2Data::decode
22:19:00.826 N Http2Data::decode - len(897)
22:19:00.826 N bytestr length = 897
22:19:00.826 N bytestr = { "statusInfo": {
------------------------------------------------

**** headerframe reply info 
==================================================
 BODY = -> HEADERSFRAME =
                FLAGS = 4
                STREAMID = 1
                HDRBLKFRAGMENT =

                    CONTENTTYPE = `application/json'
                    HDRTABLESZ = `EMPTY'
                    METHOD = `EMPTY'
                    STATUS = `201'   ####statusmsg
=====================================================
servicetype[nsmf-pdusession-post][v1][pdu-sessions][statusmsg][201],                    ReadWrite,      21      //pdusessioncreatersp
processHeaderFrame   ### keyword to look for decoding header frame




processDataFrame  #### key word to look before decoding

** IOTA callback message encoding/decoding
*** in creat post message
22:18:59.731 N SBASet::encodeField: p->name = VSMFPDUSESSIONURI
22:18:59.731 N SBASet::encodeField: field.at(p->name) = http://testuri2.new/nsmf-pdusession/v1/pdu-sessions/vsmfPduSessionUriaab
22:18:59.732 N SBAString::encode
22:18:59.732 N fldlen = 72
#### callbackURI = http://testuri2.new/nsmf-pdusession/v1/pdu-sessions/vsmfPduSessionUri
#### save callbackURI here, for later using decode message from PATH   [/nsmf-pdusession/v1/pdu-sessions/vsmfPduSessionUri]
22:18:59.732 N populateServiceDictionary, Json Callback String List = smf-post:27,400:19,403:19,404:19,411:19,413:19,415:19,429:19,500:19,503:19|smf-post/modify:28,200:29,400:19,403:19,404:19,411:19,413:19,415:19,429:19,500:19,503:19
22:18:59.732 N populateServiceDictionaryItem, Json Callback String = smf-post:27,400:19,403:19,404:19,411:19,413:19,415:19,429:19,500:19,503:19, callbackURI = http://testuri2.new/nsmf-pdusession/v1/pdu-sessions/vsmfPduSessionUriaab
22:18:59.732 N populateServiceDictionaryItem: networkFunction = smf, method = -post, suffix =
22:18:59.732 N populateServiceDictionaryItem, Json Callback String = smf-post/modify:28,200:29,400:19,403:19,404:19,411:19,413:19,415:19,429:19,500:19,503:19, callbackURI = http://testuri2.new/nsmf-pdusession/v1/pdu-sessions/vsmfPduSessionUriaab
22:18:59.732 N populateServiceDictionaryItem: networkFunction = smf, method = -post, suffix = /modify
22:18:59.733 N SBASet::encode out->cur = 470 after VSMFPDUSESSIONURI

=========================

http2blk.sdt
----------------------------------------
//NSMF services
servicetype[nsmf-pdusession-post],                     ReadWrite,      Dictionary
servicetype[nsmf-pdusession-post][nftype],             ReadWrite,      "smf"
servicetype[nsmf-pdusession-post][5],                  ReadWrite,      17      //retrievesmcontextreq
servicetype[nsmf-pdusession-post][3],                  ReadWrite,      20      //pdusessioncreatereq
servicetype[nsmf-pdusession-post][5],                  ReadWrite,      23      //updatepdusessionreq
servicetype[nsmf-pdusession-post][5],                  ReadWrite,      26      //releasepdusessionreq
servicetype[nsmf-pdusession-post][3],                  ReadWrite,      1       //createsmcontextreq
servicetype[nsmf-pdusession-post][4],                  ReadWrite,      27      //pdusessionstatusnotify ### both they are number 4 means  path string seperated with slash
servicetype[nsmf-pdusession-post][4],                  ReadWrite,      16      //smstatuscontextnotify
servicetype[nsmf-pdusession-post][5],                  ReadWrite,      4       //releasesmcontextreq
servicetype[nsmf-pdusession-post][5],                  ReadWrite,      13      //updatesmcontextreq

----------------------------------------

*** log message iota.log 
when receiving notify_hdrframe but no create_pdu_session_post to save URI, then it won't know which type of message the later dataframe will be.
recv http2sut -> http2sim -type HEADERSFRAME -msg pdu_session_notify_hdrframe_req -mapping ::c_ue
-----------
21:47:54.174 N Message after decode:
        HTTP2 template

            BODY = -> HEADERSFRAME =
                FLAGS = $04
                STREAMID = $00000001
                HDRBLKFRAGMENT =

                    AUTHORITY = `2511:0:0:993::20:8080'
                    CONTENTTYPE = `application/json'
                    HDRTABLESZ = `4096'
                    METHOD = `POST'
                    PATH = `/nsmf-pdusession/v1/pdu-sessions/vsmfPduSessionUri'
                    SCHEME = `http'
21:47:54.175 N processHeaderFrame: Enter
21:47:54.175 N processHeaderFrame: connname=http2simhttp2sut
21:47:54.175 N processHeaderFrame: pathstr=/nsmf-pdusession/v1/pdu-sessions/vsmfPduSessionUri
21:47:54.175 N processHeaderFrame: pathlen=50
21:47:54.175 N processHeaderFrame: Rervice NOT found using precise methodsourceURI: [/nsmf-pdusession/v1/pdu-sessions/vsmfPduSessionUri], apistart=0.
21:47:54.175 N processHeaderFrame: nftype = smf, stype = nsmf-pdusession-postservicename = nsmf-pdusession.
21:47:54.175 N processHeaderFrame: service NOT found using precise method. Try again, but prefer _var_ over precise.
21:47:54.175 N processHeaderFrame: nftype = smf, stype = nsmf-pdusession-postservicename = nsmf-pdusession.
21:47:54.175 N processHeaderFrame: Resource NOT found for [vsmfPduSessionUri][reqmsg] in service dictionary.
21:47:54.176 N processHeaderFrame: Use old dictionary to populate rsp codes for path /nsmf-pdusession/v1/pdu-sessions/vsmfPduSessionUriprocessHeaderFrame: DEFAULT service found for: http2sim servicetype.nsmf-pdusession-post.4 16
21:47:54.176 N processContentType: Enter
21:47:54.176 N getDefptr: connname=http2simhttp2sut
21:47:54.176 N processContentType: contenttype=application/json
21:47:54.176 N processHeaderFrame: HTTP2BLK streamiddata[http2simhttp2sut][1] =
         boundary = `EMPTY'
         contenttype = `json'
         nftype = `smf'
         sbamsg = `16'
         servicename = `nsmf-pdusession'
21:47:54.177 B [http2sim.http2rtr:(135.111.215.169:57353|19:1459)] http2sim.http2rtr sending message = HEADERSFRAME template

            BODY = -> HEADERSFRAME =
                FLAGS = $04
                STREAMID = $00000001
------------------------------

* iota log analysing
** http1 encoding delimeter
after encode
bytestr=

** http2 encoding delimeter
after encode
enc_bytes=
03:46:29.881 N Message before encode:
        HTTP2 template

            BODY = -> DATAFRAME =
                FLAGS = 1
                STREAMID = 1
                DATA = NSMF template

                    BODY = -> CREATESMCONTEXTREQ =
                        SUPI = imsi-310012601000000
                        UNAUTHENTICATEDSUPI = false
                        PEI = imei-123456789012345
                        GPSI = msisdn-310012601000000


egrep -n '^\s+/|^\s{4}\w' TS29503*.yaml



/local/ltemme/iota/iota_latest/bin/IOTA -f iota.log -c $'\nEXP-EXECUTOR-FACTORY DEFAULT\n{\n\tPackage="Load"\n\tPackage="Rand"\n\tPackage="Bceval"\n\tPackage="Sleep"\n\tPackage="When"\n\tPackage="Resource"\n\tPackage="HexString"\n\tPackage="Exit"\n\tPackage="Log"\n\tPackage="CommonLTE"\n\tPackage="Configuration"\n\tPackage="GMA"\n\tPackage="Simulator"\n\tPackage="Connection"\n\tPackage="WiseMsg"\n\tPackage="Timer"\n\tPackage="Executor"\n\tPackage="UmtsLIG"\n\tCommand="source $env(IOTA)/tcl/export.tcl"\n        Command="eval $env(IOTASUBSTART)"\n        Command="when { signal SIGINT } { interrupt; };"\n        Auto_path="$env(IOTAPRELIB) $auto_path $env(IOTA)/autolib $env(IOTAPOSTLIB)"\n}\nEXP-EXECUTOR-FACTORY\n{\n\tPrompt="iota> "\n\tPackage="SystemExit"\n\tScript="stdin"\n        Command="eval $env(IOTASTART)"\n}\n' -E BMTDNb '-X4 0x71004000'




ltemme@lm191:/local/ltemme/iota/test/msgtest $  $IOTA/bin/iota -dl -E BMTDNb -f iota.log -X"4 0x71004000"
+ CONFIGOPTS=''
+ getopts 'Vvtf:d:w:W:c:C:D:L:X:E:?' optchar
+ LOOPBACK=YES
+ export LOOPBACK
+ getopts 'Vvtf:d:w:W:c:C:D:L:X:E:?' optchar
+ IOTAOPT=' -E BMTDNb'
+ export IOTAOPT
+ getopts 'Vvtf:d:w:W:c:C:D:L:X:E:?' optchar
+ IOTA_LOGFILE=iota.log
+ getopts 'Vvtf:d:w:W:c:C:D:L:X:E:?' optchar
+ TRACEOPT='-X4 0x71004000'
+ export TRACEOPT
+ getopts 'Vvtf:d:w:W:c:C:D:L:X:E:?' optchar
+ expr 7 - 1
+ shift 6
+ : /local/ltemme/iota/iota_latest
+ export IOTA
+ SESSIONID=28441
+ export SESSIONID
+ . /local/ltemme/iota/iota_latest/bin/version.env
+ IOTA_VERSION=3.0
+ export IOTA_VERSION
+ IOTA_RELEASE=iota_v3_tag0113
+ export IOTA_RELEASE
+ [[ '' == ee ]]
+ [[ -x /local/ltemme/iota/iota_latest/bin/iota.env ]]
+ . /local/ltemme/iota/iota_latest/bin/iota.env
+ uname -n
+ HOST=lm191
+ DefaultShellHost=lm191
+ export HOST DefaultShellHost
+ TCL_LIBRARY=/local/ltemme/iota/iota_latest/tcl
+ export TCL_LIBRARY
+ ITCL_LIBRARY=/local/ltemme/iota/iota_latest/tcl
+ export ITCL_LIBRARY
+ LD_LIBRARY_PATH=/local/ltemme/iota/iota_latest/lib:
+ export LD_LIBRARY_PATH
+ PATH=/local/ltemme/iota/iota_latest/bin:/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/local/ltemme/bin
+ export PATH
+ NORESERROR=1
+ export NORESERROR
+ IotaTesLog=IotaTesLog
+ export IotaTesLog
+ /local/ltemme/iota/iota_latest/bin/iotastat -a -c
T  INSTANCE             LOGIN     TIME               HOST      PORT   PID    STATUS
+ echo ''

+ [[ '' != '' ]]
+ [ YES '!=' YES ]
+ echo 'NOTE: LOOPBACK mode is turned on'
NOTE: LOOPBACK mode is turned on
+ TLSDIR=/local/ltemme/iota/tls
+ mkdir -p /local/ltemme/iota/tls
+ openssl req -newkey rsa:2048 -nodes -sha256 -x509 -nodes -out /local/ltemme/iota/tls/IOTAcertificate.crt -keyout /local/lteme/iota/tls/IOTAkey.rsa.pem -days 500 -subj '/C=US/ST=IL/L=Naperville/O=Nokia/OU=ION/CN=Nokia/emailAddress=iotaadmin@nokia.com'
Generating a 2048 bit RSA private key
..........+++
........................................................................+++
writing new private key to '/local/ltemme/iota/tls/IOTAkey.rsa.pem'
-----
+ openssl rsa -in /local/ltemme/iota/tls/IOTAkey.rsa.pem -pubout
+ 1> /local/ltemme/iota/tls/IOTAkey.pub
writing RSA key
+ KEYDIR=/local/ltemme/iota/keys
+ mkdir -p /local/ltemme/iota/keys
+ ln -s /local/ltemme/iota/tls/IOTAkey.rsa.pem /local/ltemme/iota/keys/NRFkey.rsa.pem
ln: failed to create symbolic link ‘/local/ltemme/iota/keys/NRFkey.rsa.pem’: File exists
+ ln -s /local/ltemme/iota/tls/IOTAkey.pub /local/ltemme/iota/keys/NRFkey.pub
ln: failed to create symbolic link ‘/local/ltemme/iota/keys/NRFkey.pub’: File exists
+ [ '' '==' YES ]
+ IOTAPRELIB=''
+ export IOTAPRELIB
+ IOTAPOSTLIB=''
+ export IOTAPOSTLIB
+ IOTASUBSTART=''
+ export IOTASUBSTART
+ IOTASTART='loadConfig lte.cfg'
+ export IOTASTART
+ [ ! iota.log ]
+ echo 'NOTE: Starting IOTA now ......'
NOTE: Starting IOTA now ......
+ /local/ltemme/iota/iota_latest/bin/IOTA -f iota.log -c $'\nEXP-EXECUTOR-FACTORY DEFAULT\n{\n\tPackage="Load"\n\tPackage="Rand"\n\tPackage="Bceval"\n\tPackage="Sleep"\n\tPackage="When"\n\tPackage="Resource"\n\tPackage="HexString"\n\tPackage="Exit"\n\tPackage="Log"\n\tPackage="CommonLTE"\n\tPackage="Configuration"\n\tPackage="GMA"\n\tPackage="Simulator"\n\tPackage="Connection"\n\tPackage="WiseMsg"\n\tPackage="Timer"\n\tPackage="Executor"\n\tPackage="UmtsLIG"\n\tCommand="source $env(IOTA)/tcl/export.tcl"\n        Command="eval $env(IOTASUBSTART)"\n        Command="when { signal SIGINT } { interrupt; };"\n        Auto_path="$env(IOTAPRELIB) $auto_path $env(IOTA)/autolib $env(IOTAPOSTLIB)"\n}\nEXP-EXECUTOR-FACTORY\n{\n\tPrompt="iota> "\n\tPackage="SystemExit"\n\tScript="stdin"\n        Command="eval $env(IOTASTART)"\n}\n' -E BMTDNb '-X4 0x71004000'
***************************************************
*
*Release   : iota_v3_tag0113
*Built on  : wmm-iotarh6x32
* Lawful Interception related
** documents
 3gpp 33128 Protocol and procedures for Lawful Interception 
 pdf document for ETSI TS 103 221-1 : 
 xsd files 
* iota GDB usage
** runiota firstly
** gdb using processid to attach runiota executable file
#gdb  /local/ltemme/iota/iota_latest/bin/IOTA $(pgrep -n IOTA) |tee gdb.out 
gdb  -p  $(pgrep -n IOTA)  

** inside gdb prompt
  set substitute-path ../../../../../../../../iota /local/ltemme/iota/iota_msglen/iota 
  dir /local/ltemme/iota/iota_imr/iota/ctpapp/lte/message/ 
  dir /local/ltemme/iota/iota_imr/iota/ctpapp/lte/base-w/msg
  dir /local/ltemme/iota/iota_imr/iota/ctpapp/lte/wiseiota/protocol/com
  dir /local/ltemme/iota/iota_imr/iota/ctpapp/lte/eps/msg/ 
  break Decoder::decode 
  continue 

** source test file in runiota prompt

** back to gdb prompt
the program halted

** other gdb command
watch _data[1] if _data[1]=16 
Continue 

   x/64xb this->_data 
   dir /local/ltemme/iota/iota_msglen/iota/ctpapp/lte/message 
   commands 

   set trace-commands off 

   set set logging off 

   set logging file data.txt 

   printf "watch ((char*) (*0x%x))[2] if (((char*) (*0x%x))[0] == 0 && ((char*) (*0x%x))[1] == 16 && ((char*) (*0x%x))[2] == 0)",_data,_data,_data,_data 

   source data.txt 

   end 
    watch ((char*) (*0x92727f8))[2] if (((char*) (*0x92727f8))[0] == 0 && ((char*) (*0x92727f8))[1] == 16 && ((char*) (*0x92727f8))[2] == 0) 
     b DOE-Postmaster.C:1216 
     commands 
     Where 
     c 
     end 

      b  CommonlteProxy.C:221 
      commands 
      Where 
      c 
      end 

      ============================================================ 
      b  SSL_SOCK_SEQPACK_Connector.cpp:469 
      commands 
      c 
      end 

  SSL_SOCK_SEQPACK_Connector.cpp:511 


* iota debug 
Scenario.tcl Template.tcl
Tcl/Itcl debugging – iotavartrace, iotaproctrace, set errorInfo, puts/log/report statements 

* IOTA simulator
git log show a comment with "IOTA Code Base for 5G HTTP2"
its a base code for 5g http2 simulator


** iota wisesim 
*** a simulator constructor function
 protocol ## releate to some type of protocol
 an according router fsm to new 

HTTP1::HTTP1( WISESIM_LWP& parnt,
               ConfigurationBlock* config,
               const RWCString& alias,
               const RWCString& highestLevelPostMaster,
               LTE *LTEComposite
       )
       :WiseSim(parnt, config, alias, highestLevelPostMaster, LTEComposite)
       ,_http1rtr(0)
       _blkdataptr = new Sdt(system_sdt, getSdtFile("http1blk.sdt"));
       (*_blkdataptr)["ENTITYNAME"] = alias.data();
       (*_blkdataptr)["ENTITYTYPE"] = config->classname().data();

       initSdtByConfig(config, _blkdataptr);
       (*(system_sdt->get_symbol_table()))[alias.data()] = *(_blkdataptr->get_symbol_table());



       Protocol::Package::require("Http1"); 

       // Make HTTP1 router
       Sdt* fsmsdtptr = new Sdt(_blkdataptr, getSdtFile("http1rtr.sdt"));
       Fsm* fsmptr = new http1rtrfsm(*_blkdataptr);
       fsmptr->name("http1rtr");
       _http1rtr = new WiseFsm(fsmsdtptr,
                             _blkdataptr,
                             fsmptr,
                             parnt,
                             config->param(0) + ".http1rtr",
                             "",
                             this);

*** how to create the instance with the constructor(new)
the instance name is the alias, which will be refered in iota script later on
void* EPS_Factory::make(ConfigurationBlock* c, void* parameter)
{.......
        } else if (className == "LteLIG") {
            msg = "NOTE: Constructing " + className + " simulator: " + alias;
            cout << msg << endl;
            lw.log('N', msg);
            returnValue = new LteLIG(ltelwp, c, alias, higherPM);
##c is the configure block, alias is the simulator's instance name, higherPM is such as (135.111.25.169:34187|0:0)
        } else if (className == "gUE") {
            msg = "NOTE: Constructing " + className + " simulator: " + alias;
            cout << msg << endl;
            lw.log('N', msg);
            returnValue = new gUE(ltelwp, c, alias, higherPM);

*** iota simulator constructor process
11:03:01.292 N NOTE: Constructing FIVEGICF simulator: icf1_s
11:03:01.293 N NOTE: Reloading AMF data block: amf_net1
11:03:01.296 b DOE:  LWP Instance (338) created
11:03:01.296 N [icf1_s-amfs:(10.39.144.173:42458|20:1153)] icf1_s-amfs NOTE: TCP Acceptor: icf1_s-amfs is listening at: 172.16.59.97:20102
11:03:01.298 I iota> 
11:03:01.527 N NOTE: Constructing HTTP1 simulator: admf1_s
11:03:01.529 N NOTE: Initializing Protocol: FiveGLiX1
11:03:01.530 N NOTE: Reloading AMF data block: amf_net1
11:03:01.531 b DOE:  LWP Instance (339) created
11:03:01.531 N [admf1_s-amfs:(10.39.144.173:42458|20:1158)] admf1_s-amfs NOTE: TCP Acceptor: admf1_s-amfs is listening at: 172.16.59.96:20103
11:03:01.532 I iota> 
11:03:02.768 N NOTE: Reloading AMF data block: amf_net1
11:03:02.769 N NOTE: Constructing HTTP1 simulator: admf1_c
11:03:02.772 b DOE:  LWP Instance (340) created
11:03:02.772 b DOE: TCPConnector::Open - use local address and SO_REUSEADDR
11:03:02.777 N [admf1_c-amf_net1:(10.39.144.173:42458|20:1164)] admf1_c-amf_net1 NOTE: TCP (c) Connection: admf1_c-amf_net1 established.
        Remote Address: 172.16.46.241:443
                Local  Address: 172.16.59.96:25000
                11:03:02.778 N NOTE: admf1_c connection to amf_net1 is now open
                11:03:02.779 I iota> 
                11:03:03.024 U amf_net1 <--- DATAREQ(CREATEDESTINATIONREQ) ---- admf1_c 
                11:03:03.025 U >>>>>> SEND MESSAGE TEMPLATE: basic_lix1_createdestination_req 

*** loop test?
two entity(simulator) 
one is http1sim another is http1sut
01:47:55.247 U http1sut <--- DATAREQ ---- http1sim
01:47:55.250 U >>>>>> SEND MESSAGE TEMPLATE: example_req
###get message from queue
01:47:55.252 T >> getMsgFromQueue() wait for 10 secs
01:47:55.253 B [http1sim:(135.111.25.169:48277|19:1494)] http1sim : Receive DeliveryRequest message. Type [WiseMsg], From [():135.111.25.169:48277|11:0]
01:47:55.253 B [http1sim.http1rtr:(135.111.25.169:48277|19:1495)] http1sim.http1rtr handle message internal = FALSE
01:47:55.253 N enclen = 0
01:47:55.253 N http1sim send it ipnetwork procedue rtr
01:47:55.253 B [http1sim.http1rtr:(135.111.25.169:48277|19:1495)] http1sim.http1rtr sending message = HTTP1 template
            BODY = -> DATAREQ =                                                                                              
        from PID=1495(http1sim::http1rtr) to PID=13                                                                          
01:47:55.253 B PID=1495(http1sim::http1rtr) keeps in the same state Processing                                               
01:47:55.253 T [IPNETWORK:(135.111.25.169:48277|19:13)] IPNETWORK <- WiseMsg                                                 
01:47:55.253 T [IPNETWORK:(135.111.25.169:48277|19:13)] IPNETWORK handleOutBound()                                           
01:47:55.253 m [IPNETWORK:(135.111.25.169:48277|19:13)] IPNETWORK http1sut <= http1sim                                       
        HTTP1 template                                                                                                       
            BODY = -> DATAREQ =                                                                                              
                REQUESTLINE =                                                                                                
01:47:55.253 T [Http1358:(135.111.25.169:48277|380:1592)] Http1358 <- PH::messageHandler WiseMsg
01:47:55.253 T [Http1358:(135.111.25.169:48277|380:1592)] Http1358 >> PH::handleOutBound()
01:47:55.253 T [Http1358:(135.111.25.169:48277|380:1592)] Http1358 >> PH::handleOutBound(Http1)
01:47:55.253 T MsgLenCheck(Http1)::encodeApplMessage()
----------------------------

STATE Processing;
        INPUT HTTP1;
        /* Message may come from Script or AMF or http1_amf FSM */
        DECISION 'SENDER';
        (IPNETWORK):  ###when INPUT message HTTP1's SENDER is IPNETWORK
                                /* route to scenario */
        ELSE:
                TASK 'GENMSGDEBUG(ENTITYNAME << "send it ipnetwork procedue rtr " << "\\n")';
                /* send it to IPNETWORK */
                OUTPUT EXTERNAL rcvd_prim TO IPNETWORK;
--------------------------------------------------
.......
.........
01:47:55.254 M [http1sim-amfs-0:(135.111.25.169:48277|20:1661)] http1sim-amfs-0 sending message
01:47:55.255 T [http1sut-http1sim:(135.111.25.169:48277|20:1594)] http1sut-http1sim >> Connection::handle_input()
01:47:55.255 T [http1sut-http1sim:(135.111.25.169:48277|20:1594)] http1sut-http1sim length from TCP Read = 91
01:47:55.255 M [http1sut-http1sim:(135.111.25.169:48277|20:1594)] http1sut-http1sim received message
        0000  50 4f 53 54 20 2f 65 78 61 6d 70 6c 65 2f 70 61  POST /example/pa
        0016  74 68 20 48 54 54 50 2f 31 2e 31 0d 0a 63 6f 6e  th HTTP/1.1..con
        0032  74 65 6e 74 2d 74 79 70 65 3a 20 74 65 78 74 2f  tent-type: text/
        0048  78 6d 6c 0d 0a 63 6f 6e 74 65 6e 74 2d 6c 65 6e  xml..content-len
        0064  67 74 68 3a 20 30 0d 0a 68 6f 73 74 3a 20 6d 79  gth: 0..host: my
        0080  2d 73 65 72 76 65 72 0d 0a 0d 0a                 -server....
01:47:55.255 T [http1sut-http1sim:(135.111.25.169:48277|20:1594)] http1sut-http1sim >> Connection::sendToOwner()
01:47:55.255 T [Http1359:(135.111.25.169:48277|381:1593)] Http1359 <- PH::messageHandler Primitive
01:47:55.255 T [Http1359:(135.111.25.169:48277|381:1593)] Http1359 PH::messageHandler: msg from connection
01:47:55.255 T [Http1359:(135.111.25.169:48277|381:1593)] Http1359 >> PH::handleInBound()
01:47:55.255 T [Http1359:(135.111.25.169:48277|381:1593)] Http1359 PH::setAttrib: prim - stream based
01:47:55.255 T Decoder::getHttp1Length Enter
01:47:55.255 T Decoder::getHttp1Length content-length found
01:47:55.255 T Decoder::getHttp1Length CR LF CR LF found after content-length value
01:47:55.255 T Decoder::getHttp1Length msglen = 91
01:47:55.255 T Decoder::getHttp1Length _size = 91
01:47:55.255 N Entering GPD::Sequence::decodeField(BODY)
.........................
.........................

01:47:55.257 N Message after decode:
        HTTP1 template

            BODY = -> DATAREQ =
                REQUESTLINE =
                    HTTP1HOST = my-server
01:47:55.257 N http1sut RouteToSenario procedue rtr
01:47:55.257 T putMsgToQueue() >>
01:47:55.257 T message count after: 1
01:47:55.257 T << putMsgToQueue()
01:47:55.257 B PID=1497(http1sut::http1rtr) keeps in the same state Processing

--------------------------------------------
STATE Processing;
        INPUT HTTP1;
        /* Message may come from Script or AMF or http1_amf FSM */
        DECISION 'SENDER';
        (IPNETWORK):  ###when INPUT message HTTP1's SENDER is IPNETWORK
                                /* route to scenario */
                                TASK 'GENMSGDEBUG(ENTITYNAME << " RouteToSenario procedue rtr " << "\\n")';
                                TASK 'WiseMsg *wmsg = new WiseMsg(rcvd_prim, TRUE)';
                                TASK 'UPMsgQueue::instance()->putMsgToQueue(wmsg)';
-----------------------------------------------------------------------


** IOTA itcl extension
addCommand("loadConfig", ItclConfigLoadExtension)

 /* Description: Itcl proxy to the "loadConfig" tcl command. It loads a configuration
 *      file and does the make according to the contents of the configuration       file.  */

int ItclConfigLoadExtension(ClientData clientData, Tcl_Interp* interp, int objc, Tcl_Obj* CONST objv[] )

*** link itcl class with real simulator c++ instance with alias name
::itcl::class WiseSim {
        inherit CommonLTE

        constructor {a1} {CommonLTE::constructor $a1} {}
----------------
::itcl::class LteLIG {
        inherit WiseSim
        .............
        constructor {a1} {WiseSim::constructor $a1} {
        }

in the config block file:
LteLIG lic1 {....}      <C++ simulator class name> <aliasname>

synax:   <tcl class name>  <alias name which in c++ instance creation with config block> < tcl class instance name>
in tcl shell:
LteLIG lic1 <tcl instance name>

*** itcl class method
::itcl::body LteLIG::deactintreq


** IOTA itcl interface with simulator

HTTP1.tcl|47| ::itcl::body HTTP1::connect { rmtname } {
HTTP1.tcl|56| ::itcl::body HTTP1::openConn {args} {
HTTP1.tcl|102| ::itcl::body HTTP1::closeConn {args} {
HTTP1.tcl|148| ::itcl::body HTTP1::checkConn {args} {
HTTP1.tcl|182| ::itcl::body HTTP1::keepalive { status args } {
HTTP1.tcl|235| ::itcl::body HTTP1::keepaliversp { status args } {
HTTP1.tcl|288| ::itcl::body HTTP1::ping { args } {
HTTP1.tcl|334| ::itcl::body HTTP1::pingrsp { status args } {
HTTP1.tcl|387| ::itcl::body HTTP1::getutctime { } {
HTTP1.tcl|392| ::itcl::body HTTP1::getx1tid { } {

::itcl::body HTTP1::connect { rmtname } {
       ::set m [Message #auto _HTTP1CONNECT]
       $m set localName $ltealias
       $m set remoteName $rmtname
       $m send $address
       ::itcl::delete object $m
}


** IOTA simulator fsm(finite state machine)
*.sd file is the stte machine definition
** iota simulator constructor process
11:03:01.292 N NOTE: Constructing FIVEGICF simulator: icf1_s
11:03:01.293 N NOTE: Reloading AMF data block: amf_net1
11:03:01.296 b DOE:  LWP Instance (338) created
11:03:01.296 N [icf1_s-amfs:(10.39.144.173:42458|20:1153)] icf1_s-amfs NOTE: TCP Acceptor: icf1_s-amfs is listening at: 172.16.59.97:20102
11:03:01.298 I iota> 
11:03:01.527 N NOTE: Constructing HTTP1 simulator: admf1_s
11:03:01.529 N NOTE: Initializing Protocol: FiveGLiX1
11:03:01.530 N NOTE: Reloading AMF data block: amf_net1
11:03:01.531 b DOE:  LWP Instance (339) created
11:03:01.531 N [admf1_s-amfs:(10.39.144.173:42458|20:1158)] admf1_s-amfs NOTE: TCP Acceptor: admf1_s-amfs is listening at: 172.16.59.96:20103
11:03:01.532 I iota> 
11:03:02.768 N NOTE: Reloading AMF data block: amf_net1
11:03:02.769 N NOTE: Constructing HTTP1 simulator: admf1_c
11:03:02.772 b DOE:  LWP Instance (340) created
11:03:02.772 b DOE: TCPConnector::Open - use local address and SO_REUSEADDR
11:03:02.777 N [admf1_c-amf_net1:(10.39.144.173:42458|20:1164)] admf1_c-amf_net1 NOTE: TCP (c) Connection: admf1_c-amf_net1 established.
        Remote Address: 172.16.46.241:443
                Local  Address: 172.16.59.96:25000
                11:03:02.778 N NOTE: admf1_c connection to amf_net1 is now open
                11:03:02.779 I iota> 
                11:03:03.024 U amf_net1 <--- DATAREQ(CREATEDESTINATIONREQ) ---- admf1_c 
                11:03:03.025 U >>>>>> SEND MESSAGE TEMPLATE: basic_lix1_createdestination_req 

*** loop test?
two entity(simulator) 
one is http1sim another is http1sut
01:47:55.247 U http1sut <--- DATAREQ ---- http1sim
01:47:55.250 U >>>>>> SEND MESSAGE TEMPLATE: example_req
###get message from queue
01:47:55.252 T >> getMsgFromQueue() wait for 10 secs
01:47:55.253 B [http1sim:(135.111.25.169:48277|19:1494)] http1sim : Receive DeliveryRequest message. Type [WiseMsg], From [():135.111.25.169:48277|11:0]
01:47:55.253 B [http1sim.http1rtr:(135.111.25.169:48277|19:1495)] http1sim.http1rtr handle message internal = FALSE
01:47:55.253 N enclen = 0
01:47:55.253 N http1sim send it ipnetwork procedue rtr
01:47:55.253 B [http1sim.http1rtr:(135.111.25.169:48277|19:1495)] http1sim.http1rtr sending message = HTTP1 template
            BODY = -> DATAREQ =                                                                                              
        from PID=1495(http1sim::http1rtr) to PID=13                                                                          
01:47:55.253 B PID=1495(http1sim::http1rtr) keeps in the same state Processing                                               
01:47:55.253 T [IPNETWORK:(135.111.25.169:48277|19:13)] IPNETWORK <- WiseMsg                                                 
01:47:55.253 T [IPNETWORK:(135.111.25.169:48277|19:13)] IPNETWORK handleOutBound()                                           
01:47:55.253 m [IPNETWORK:(135.111.25.169:48277|19:13)] IPNETWORK http1sut <= http1sim                                       
        HTTP1 template                                                                                                       
            BODY = -> DATAREQ =                                                                                              
                REQUESTLINE =                                                                                                
01:47:55.253 T [Http1358:(135.111.25.169:48277|380:1592)] Http1358 <- PH::messageHandler WiseMsg
01:47:55.253 T [Http1358:(135.111.25.169:48277|380:1592)] Http1358 >> PH::handleOutBound()
01:47:55.253 T [Http1358:(135.111.25.169:48277|380:1592)] Http1358 >> PH::handleOutBound(Http1)
01:47:55.253 T MsgLenCheck(Http1)::encodeApplMessage()
----------------------------

STATE Processing;
        INPUT HTTP1;
        /* Message may come from Script or AMF or http1_amf FSM */
        DECISION 'SENDER';
        (IPNETWORK):  ###when INPUT message HTTP1's SENDER is IPNETWORK
                                /* route to scenario */
        ELSE:
                TASK 'GENMSGDEBUG(ENTITYNAME << "send it ipnetwork procedue rtr " << "\\n")';
                /* send it to IPNETWORK */
                OUTPUT EXTERNAL rcvd_prim TO IPNETWORK;
--------------------------------------------------
.......
.........
01:47:55.254 M [http1sim-amfs-0:(135.111.25.169:48277|20:1661)] http1sim-amfs-0 sending message
01:47:55.255 T [http1sut-http1sim:(135.111.25.169:48277|20:1594)] http1sut-http1sim >> Connection::handle_input()
01:47:55.255 T [http1sut-http1sim:(135.111.25.169:48277|20:1594)] http1sut-http1sim length from TCP Read = 91
01:47:55.255 M [http1sut-http1sim:(135.111.25.169:48277|20:1594)] http1sut-http1sim received message
        0000  50 4f 53 54 20 2f 65 78 61 6d 70 6c 65 2f 70 61  POST /example/pa
        0016  74 68 20 48 54 54 50 2f 31 2e 31 0d 0a 63 6f 6e  th HTTP/1.1..con
        0032  74 65 6e 74 2d 74 79 70 65 3a 20 74 65 78 74 2f  tent-type: text/
        0048  78 6d 6c 0d 0a 63 6f 6e 74 65 6e 74 2d 6c 65 6e  xml..content-len
        0064  67 74 68 3a 20 30 0d 0a 68 6f 73 74 3a 20 6d 79  gth: 0..host: my
        0080  2d 73 65 72 76 65 72 0d 0a 0d 0a                 -server....
01:47:55.255 T [http1sut-http1sim:(135.111.25.169:48277|20:1594)] http1sut-http1sim >> Connection::sendToOwner()
01:47:55.255 T [Http1359:(135.111.25.169:48277|381:1593)] Http1359 <- PH::messageHandler Primitive
01:47:55.255 T [Http1359:(135.111.25.169:48277|381:1593)] Http1359 PH::messageHandler: msg from connection
01:47:55.255 T [Http1359:(135.111.25.169:48277|381:1593)] Http1359 >> PH::handleInBound()
01:47:55.255 T [Http1359:(135.111.25.169:48277|381:1593)] Http1359 PH::setAttrib: prim - stream based
01:47:55.255 T Decoder::getHttp1Length Enter
01:47:55.255 T Decoder::getHttp1Length content-length found
01:47:55.255 T Decoder::getHttp1Length CR LF CR LF found after content-length value
01:47:55.255 T Decoder::getHttp1Length msglen = 91
01:47:55.255 T Decoder::getHttp1Length _size = 91
01:47:55.255 N Entering GPD::Sequence::decodeField(BODY)
.........................
.........................

01:47:55.257 N Message after decode:
        HTTP1 template

            BODY = -> DATAREQ =
                REQUESTLINE =
                    HTTP1HOST = my-server
01:47:55.257 N http1sut RouteToSenario procedue rtr
01:47:55.257 T putMsgToQueue() >>
01:47:55.257 T message count after: 1
01:47:55.257 T << putMsgToQueue()
01:47:55.257 B PID=1497(http1sut::http1rtr) keeps in the same state Processing

--------------------------------------------
STATE Processing;
        INPUT HTTP1;
        /* Message may come from Script or AMF or http1_amf FSM */
        DECISION 'SENDER';
        (IPNETWORK):  ###when INPUT message HTTP1's SENDER is IPNETWORK
                                /* route to scenario */
                                TASK 'GENMSGDEBUG(ENTITYNAME << " RouteToSenario procedue rtr " << "\\n")';
                                TASK 'WiseMsg *wmsg = new WiseMsg(rcvd_prim, TRUE)';
                                TASK 'UPMsgQueue::instance()->putMsgToQueue(wmsg)';
-----------------------------------------------------------------------

*** fsm handle message from IPNETWORK
                        DECISION 'workMode == IPNetwork::MODE_SCRIPTING';
                        (TRUE):
                                /* Forward messages requiring processing to fivegx2_amf FSM */
                                DECISION 'FIVEGX2BLK(msg2que) == "off"';
                                (TRUE):
                                        /* route message to simulator */
                                        TASK 'Value fivegx2msg = rcvd_prim';
                                        /* change the FIVEGX2PDU type to real message TYPE */
                                        TASK 'fivegx2msg.type(fivegx2Type)';
                                        CALL RouteToAmfFsm(fivegx2msg);
                                        NEXTSTATE -;
                                ELSE:
                                ENDDECISION;

                                /* route to scenario */## if msg2que on
                                TASK 'WiseMsg *wmsg = new WiseMsg(rcvd_prim, TRUE)';
                                TASK 'UPMsgQueue::instance()->putMsgToQueue(wmsg)';
                        ELSE:
                                /* route message to simulator */
                                TASK 'Value fivegx2msg = rcvd_prim';
                                /* change the FIVEGX2PDU type to real message TYPE */
                                TASK 'fivegx2msg.type(fivegx2Type)';
                                CALL RouteToAmfFsm(fivegx2msg);
                                NEXTSTATE -;
                        ENDDECISION;


*** iota simulator messageque on/off
when recv a message and decode it, then rtr st will decide to put it to messageque or send to the actual dst simulator.
**** messge queue on
20:30:57.308 B [fivegx2sut.fivegx2rtr:(135.111.25.169:36160|19:1521)] fivegx2sut.fivegx2rtr handle message internal = FALSE
20:30:57.308 T putMsgToQueue() >>

**** messge queue off
20:28:53.801 B [fivegx2sut.fivegx2rtr:(135.111.25.169:56090|19:1520)] fivegx2sut.fivegx2rtr handle message internal = FALSE
20:28:53.801 B [fivegx2sut.fivegx2rtr:(135.111.25.169:56090|19:1520)] fivegx2sut.fivegx2rtr sending message = KEEPALIVEREQ template

        from PID= 1520(fivegx2sut::fivegx2rtr) to PID=1619
### this 1619 is entity fivegx2sut's amf fsm: fivegx2_amf.sd 
20:28:53.801 B PID=1520(fivegx2sut::fivegx2rtr) keeps in the same state Processing
20:28:53.801 B [():135.111.25.169:56090|19:1619]  handle message internal = TRUE
20:28:53.801 N fivegx2sut  fivegx2 message type rtr
20:28:53.802 N mkX2KeepAliveAck message:

*** iota simulator encode/decode
**** encode 
***** encode timing
when ipnetwork get the message from netowrk
-------
02:19:58.857 T [IPNETWORK:(135.111.25.169:48904|19:13)] IPNETWORK <- WiseMsg
02:19:58.857 T [IPNETWORK:(135.111.25.169:48904|19:13)] IPNETWORK handleOutBound()
02:19:58.857 m [IPNETWORK:(135.111.25.169:48904|19:13)] IPNETWORK http1sim <= http1sut
 HTTP1 template

            BODY = -> DATARSP =
                STATUSLINE =
                    HTTPVERSION = HTTP/1.1
                    STATUS = 200
                    REASON = OK
                HEADERFIELDS =
                    CONTENTTYPE = text/xml
                    CONTENTLENGTH = 607
                    HTTP1HOST = NIL
                    CONNECTION = keep-alive
                DATA = FIVEGLIX1 template

                    BODY = -> ACTIVATETASKRSP =
                        ADMFIDENTIFIER = admfID
-----------------------

***** how to encode
-----------------------------------------------------------------------
02:19:58.857 T [Http1359:(135.111.25.169:48904|381:1586)] Http1359 <- PH::messageHandler WiseMsg
02:19:58.857 T [Http1359:(135.111.25.169:48904|381:1586)] Http1359 >> PH::handleOutBound()
02:19:58.857 T [Http1359:(135.111.25.169:48904|381:1586)] Http1359 >> PH::handleOutBound(Http1)
02:19:58.857 T MsgLenCheck(Http1)::encodeApplMessage()
02:19:58.857 N Entering GPD::Sequence::encodeField
02:19:58.857 N GPD::Choice::encode
02:19:58.857 N Http1Seq::encode
02:19:58.857 N out->cur = 0
02:19:58.857 N name = DATARSP
02:19:58.857 N Http1Seq::encodeField: p->name = STATUSLINE
----------------------------------------------------------

Http1Seq encoding
----------------------------------------------
+Boolean Http1Seq::encode(Value& field, ioptr* out, Boolean subField)
{
    int     seqlen=0;
       Boolean version_present = FALSE;

       GENMSGDEBUG("Http1Seq::encode");
       GENMSGDEBUG("out->cur = " << out->cur << "\n");
       GENMSGDEBUG("name = " << name << "\n");

       List_of_piter<AV> iter(_fields);
       AV* p;
       while (! iter.at_end()) {

               iter.next(p);
               if (!encodeField(field, p, out)) {
                       return FALSE;
               }

       }
--------------------------------

**** decode
***** deocde timing
02:19:58.861 T [http1sim-amfs-0:(135.111.25.169:48904|20:1661)] http1sim-amfs-0 >> Connection::sendToOwner()
02:19:58.861 T [Http1358:(135.111.25.169:48904|380:1585)] Http1358 <- PH::messageHandler Primitive
02:19:58.861 T [Http1358:(135.111.25.169:48904|380:1585)] Http1358 PH::messageHandler: msg from connection
02:19:58.861 T [Http1358:(135.111.25.169:48904|380:1585)] Http1358 >> PH::handleInBound()
02:19:58.861 T [Http1358:(135.111.25.169:48904|380:1585)] Http1358 PH::setAttrib: prim - stream based
02:19:58.861 T Decoder::getHttp1Length Enter
02:19:58.861 T Decoder::getHttp1Length content-length found
02:19:58.861 T Decoder::getHttp1Length CR LF CR LF found after content-length value
02:19:58.861 T Decoder::getHttp1Length msglen = 703
02:19:58.861 T Decoder::getHttp1Length _size = 703
02:19:58.862 N Entering GPD::Sequence::decodeField(BODY)
02:19:58.862 N endPos = 703
02:19:58.862 N input->cur = 0
02:19:58.862 N GPD::Choice::decode
02:19:58.862 N GPD::Choice::decode _idflddef is set
02:19:58.862 N GPD::Choice::decode p->id/idv = 1
02:19:58.862 N Enter Http1Seq::decode
02:19:58.862 N seqLen = 703
02:19:58.862 N input->cur = 1
02:19:58.862 N Enter Http1Seq::decodeField
***** 

*** iota connection open
**** TCPcliConn:open
23:53:15.172 T [http2sut-http2sim:(135.111.25.169:56172|20:17)] http2sut-http2sim >> TCPcliConn::open()
23:53:15.172 b DOE: TCPConnector::Open - use local address and SO_REUSEADDR
23:53:15.172 N [http2sut-http2sim:(135.111.25.169:56172|20:17)] http2sut-http2sim NOTE: TCP (c) Connection: http2sut-http2sim established.
                Remote Address: 135.111.25.169:50200
                Local  Address: 135.111.25.169:20201
23:53:15.173 N NOTE: http2sut connection to http2sim is now open
23:53:15.173 B [():135.111.25.169:56172|19:18]  sending message = HTTP2 template

            BODY = -> MAGICFRAME =

**** multipleip
3:53:15.065 N umtslib2.C:setupMultipleIPAssoc: remoteData=
         localAddr = `135.111.25.169:50200'
         multipleip = `1-2', owner=http2sim.http2rtr, protocol=Http2, tranType=TCP

**** multipleip will open two enetity, the second one will be with _1
ltemme@lm191:/local/ltemme/iota/test/msgtest $ grep -i tcpcliconn::open iota.log_mip
23:18:00.534 T [http2sut-http2sim:(135.111.25.169:35969|20:19)] http2sut-http2sim >> TCPcliConn::open()
23:18:00.537 T [http2sut_1-http2sim:(135.111.25.169:35969|20:22)] http2sut_1-http2sim >> TCPcliConn::open()


**  iota cfg 
lte.cfg is the configure file for simulator
the client and server will point to each other
---------------------------------------------------------
HTTP1 http1sim {  ### <simulator name>  <entityname>
    conntype = real   ### this means this is the server side, it will accept connections
    amfs {
       http1sut {}  #### this is the client entityname, you should refer it outside this scope
       multipleip = "1-2" ### there's only one serverip:port to two clients ip:ports
       localAddr = "135.111.32.41:50100" ###server ip:port
    }
}

HTTP1 http1sut {  #### <simulator name> <aliasname>
#    conntype = real ### client need to comment this out
    amfs {
       http1sim { ### server entityname, defined as above
          multipleip = "2-1"  ### there're two clients to one serverip:port 
          localAddr = "135.111.32.41:20101,135.111.32.41:20102"  ###client ip port
       }
    }
}
------------------------------------------------------

*** runiota log
--
HTTP2 http2sim {
    priv_key     = NRFkey.rsa.pem
    conntype = real   ### http2sim only act as a tcp server
    simmaxframesz = 8192
    mmes {
       http2sut {}
       # The following servers are used for testing multiple AMF connections
       #http2sut1 {}
       #http2sut2 {}
       multipleip = "1-2"   ### one ip listen at 50000 will accept two ports 20001 and 20002
       localAddr = "135.111.25.169:50000"
    }
}

# HTTP2 ClientSUT
HTTP2 http2sut {
    amfs {
       http2sim {
          multipleip = "2-1" ### two clients port 20001 and 20002 will connect to server port 50000
          localAddr = "135.111.25.169:20001,135.111.25.169:20002"
---
------------
ltemme@lm191:/local/ltemme/iota/test/msgtest $ grep  Acceptor iota.log |grep -i http2
 http2sim-mmes >> Acceptor()
 http2sim-mmes >> TCP_Acceptor()
 http2sim-mmes >> Acceptor::regHandler(135.111.25.169:20001)  ## first client handler registered
 http2sim-mmes >> TCP_Acceptor::open()
 http2sim-mmes NOTE: TCP Acceptor: http2sim-mmes is listening at: 135.111.25.169:50000
 http2sim-mmes >> Acceptor::regHandler(135.111.25.169:20002) ## second client handler registered
##### a tcp SYN packet is coming from 20001 
 http2sim-mmes >> TCP_Acceptor::handle_input()
 http2sim-mmes >> Acceptor::getHandler(135.111.25.169:20001)
 http2sim-mmes TCP_Acceptor::handle_input - found handler for:135.111.25.169:20001
##### http2sim as a tcp server accept the connection request
 http2sim-mmes NOTE: TCP Acceptor: http2sim-mmes accepted connection request

##### a tcp SYN packet is coming from 20002 
 http2sim-mmes >> TCP_Acceptor::handle_input()
 http2sim-mmes >> Acceptor::getHandler(135.111.25.169:20002)
 http2sim-mmes TCP_Acceptor::handle_input - found handler for:135.111.25.169:20002
##### http2sim as a tcp server accept the connection request
 http2sim-mmes NOTE: TCP Acceptor: http2sim-mmes accepted connection request

 http2sim-mmes >> TCP_Acceptor::close()
 http2sim-mmes >> TCP_Acceptor::handle_close()
--------------------

client connect to the server
---------------------------------------------------------------------------------
01:28:18.861 T [IPNETWORK:(135.111.25.169:38284|19:13)] IPNETWORK >> getConnection()
01:28:18.861 D [IPNETWORK:(135.111.25.169:38284|19:13)] IPNETWORK found RegEntry for: http2suthttp2sim
01:28:18.861 T [IPNETWORK:(135.111.25.169:38284|19:13)] IPNETWORK >> getConnection()
01:28:18.861 D [IPNETWORK:(135.111.25.169:38284|19:13)] IPNETWORK found RegEntry for: http2suthttp2sim
01:28:18.861 T [IPNETWORK:(135.111.25.169:38284|19:13)] IPNETWORK >> getAcceptor()
01:28:18.861 D [IPNETWORK:(135.111.25.169:38284|19:13)] IPNETWORK found RegEntry for: http2suthttp2sim
01:28:18.861 T [http2sut-http2sim:(135.111.25.169:38284|20:1583)] http2sut-http2sim >> TCPcliConn::open()
---------------------------------------------------------------------------


close the connection
-------
ltemme@lm191:/local/ltemme/iota/test/msgtest $ grep Connection::close iota.log |grep -i http2
02:24:11.623 T [http2sut-http2sim:(135.111.25.169:38284|20:1583)] http2sut-http2sim >> Connection::close()
02:24:11.625 T [http2sut_1-http2sim:(135.111.25.169:38284|20:1586)] http2sut_1-http2sim >> Connection::close()
02:24:11.626 T [http2sim-mmes-0:(135.111.25.169:38284|20:1657)] http2sim-mmes-0 >> Connection::close()
02:24:11.626 F [http2sim-mmes-0:(135.111.25.169:38284|20:1657)] http2sim-mmes-0 Connection::close - deactivate failed
02:24:11.628 T [http2sim-mmes-0:(135.111.25.169:38284|20:1657)] http2sim-mmes-0 >> Connection::close()
02:24:11.628 N [http2sim-mmes-0:(135.111.25.169:38284|20:1657)] http2sim-mmes-0 Connection::close - already closed
02:24:11.631 T [http2sim-mmes-1:(135.111.25.169:38284|20:1660)] http2sim-mmes-1 >> Connection::close()
------------------------------------


conntype =real

*** ate runtime env
**** tcl procedure to create a NE(network element)
CreateHTTP2Server -name udm2_s -ip ${IOTA['NRF1_V4']} -port ${CMM['HTTP_PORT']} -amfip ${CMM['NNRF_V4']} -delay 5000
###network element name is udm2_s 
proc CreateHTTP2Server { args } {
        array set argarray [getargs $args [list "-name" "-ip" "-port" "-amfip"] [list "-delay"]]
        set firstip [lindex [split $argarray(-ip) ,] 0]
        set simcfg "
..........
        set siminitfilename $argarray(-name).init
        writefile $simcfgfilename $simcfg
        writefile $siminitfilename $siminit
        source $siminitfilename
        if { $argarray(-delay) != "" } {
                #after $argarray(-delay)
        }
}

**** ate cfg
ltemme@lm602:/local/ltemme/iota $ cat udm2_s.cfg
----------------------
AMF amf_net1 {
    conntype = real
        http2s {
                udm2_s {
                        multipleip = "2-1"
                        localAddr = "172.16.46.202:fp1,172.16.46.202:fp2"
#                       localAddr = "172.16.46.202:fp"
                }
        }
}
HTTP2 udm2_s {  ### HTTP2 is C++ simulator classname, and udm2_s is alias
    ip = 172.16.59.73
    amfip = 172.16.46.202
    amf1ip = 172.16.46.202

    conntype = real
        amfs {
                amf_net1 {}

                multipleip = "1-2"
                localAddr = "172.16.59.73:8080"
        }
}
------------------- 

ltemme@lm602:/local/ltemme/iota $ cat udm2_s.init
loadConfig udm2_s.cfg
HTTP2 udm2_s udm2_s  ## this is for tcl HTTP2<itcl classname> udm2_s<sim name in tcl script, could be anyone> 
                        udm2_s(instance name of C++/alias name in config)
##::itcl::class HTTP2 {}... in HTTP2.tcl file

        public method reset {level}
        public method connect { args }
        public method nr10hb { status args }
        public method nr10hbrsp { status args }
        public method openConn {args}
        public method closeConn {args}
        public method checkConn {args}
        public method keepalive { status args }
        public method keepaliversp { status args }
        public method ping { args }
        public method pingrsp { status args }
        public method genOauthAccessToken { map }
        public method genPdnConn { enctmpl global_array }
        public method base64Encode { hexstr }
        public method base64Decode { hexstr }
------------------------------------------------------------------
tcl script
----------------------
HTTP2 http2sut http2sut
HTTP2 http2sim http2sim

set isopen [http2sim checkConn -rname http2sut]
http2sut closeConn -lname http2sut_1 -rname http2sim
http2sut openConn -lname http2sut_1 -rname http2sim

send http2sut -> http2sim -msg udm_uecm_registration_hdrframe_req -mapping ::c_ue
recv http2sut -> http2sim -type HEADERSFRAME -msg udm_uecm_registration_hdrframe_req -mapping ::c_u

---------------------------------------------

itcl interface for send
------
./ctpapp/lte/umts/scripting/Scenario.tcl:583:::itcl::body Scenario::send {ne1 arrow ne2 args} {
-----------------------------------------------------------------

**** ate testcase log
---------------
02:05:34.379 N NOTE: Constructing HTTP2 simulator: udm2_s
### this the the  new HTTP2(ltelwp, c, alias, higherPM); function called in C++, alias is udm2_s
### if loadConfig this HTTP2 configuration, the HTTP2 who has alias as udm2_s is created
02:05:34.401 N [udm2_s-amfs:(135.111.249.47:36304|20:1112)] udm2_s-amfs NOTE: TCP Acceptor: udm2_s-amfs is listening at: 172.16.59.73:8080
02:05:34.401 b DOE:  LWP Instance (246) created
02:05:34.401 b DOE:  LWP Instance (247) created
02:05:34.401 b DOE:  LWP Instance (248) created
.......
02:06:26.094 N [udm2_s-amfs-0:(135.111.249.47:36304|20:2553)] udm2_s-amfs-0 NOTE: TCP (s) Connection: udm2_s-amfs-0 established.
		Remote Address: 172.16.46.202:28137
		Local  Address: 172.16.59.73:8080
02:06:26.094 N [udm2_s-amfs:(135.111.249.47:36304|20:1112)] udm2_s-amfs NOTE: TCP Acceptor: udm2_s-amfs accepted connection request
02:06:26.094 N [udm2_s-amfs-1:(135.111.249.47:36304|20:2554)] udm2_s-amfs-1 NOTE: TCP (s) Connection: udm2_s-amfs-1 established.
		Remote Address: 172.16.46.202:28136
		Local  Address: 172.16.59.73:8080
02:06:26.095 N [udm2_s-amfs:(135.111.249.47:36304|20:1112)] udm2_s-amfs NOTE: TCP Acceptor: udm2_s-amfs accepted connection request
02:06:26.104 M [udm2_s-amfs-0:(135.111.249.47:36304|20:2553)] udm2_s-amfs-0 received message
	0000  50 52 49 20 2a 20 48 54 54 50 2f 32 2e 30 0d 0a  PRI * HTTP/2.0..
	0016  0d 0a 53 4d 0d 0a 0d 0a 00 00 1e 04 00 00 00 00  ..SM............
	0032  00 00 03 00 00 00 64 00 04 00 00 ff ff 00 01 00  ......d.........
	0048  00 10 00 00 02 00 00 00 00 00 06 00 00 07 d0     ...............
02:06:26.104 M [udm2_s-amfs-1:(135.111.249.47:36304|20:2554)] udm2_s-amfs-1 received message
	0000  50 52 49 20 2a 20 48 54 54 50 2f 32 2e 30 0d 0a  PRI * HTTP/2.0..
	0016  0d 0a 53 4d 0d 0a 0d 0a 00 00 1e 04 00 00 00 00  ..SM............
	0032  00 00 03 00 00 00 64 00 04 00 00 ff ff 00 01 00  ......d.........
	0048  00 10 00 00 02 00 00 00 00 00 06 00 00 07 d0     ...............
02:06:26.105 m [IPNETWORK:(135.111.249.47:36304|19:4)] IPNETWORK amf_net1_1 => udm2_s
	
--------------------------	
cat udm2_c.cfg
AMF amf_net1 {
    conntype = real
        http2s {
                udm2_c {
                        localAddr = "172.16.46.224:8080"
                }
        }
}

HTTP2 udm2_c {
        ip = 172.16.59.74
    amfip = 172.16.46.224
    amf1ip = 172.16.46.224

        amfs {
                amf_net1 {
                    localAddr = "172.16.59.74:8080"
                }

        }
}
---------------------------------- 

02:05:34.408 N NOTE: Reloading AMF data block: amf_net1
02:05:34.409 N NOTE: Constructing HTTP2 simulator: udm2_c
02:05:34.427 b DOE:  LWP Instance (249) created
02:05:34.427 b DOE: TCPConnector::Open - use local address and SO_REUSEADDR
02:05:34.428 I iota> 
02:05:34.438 N [udm2_c-amf_net1:(135.111.249.47:36304|20:1124)] udm2_c-amf_net1 NOTE: TCP (c) Connection: udm2_c-amf_net1 established.
		Remote Address: 172.16.46.224:8080
		Local  Address: 172.16.59.74:8080
02:05:34.438 N NOTE: udm2_c connection to amf_net1 is now open
02:05:34.439 N udm2_c ---- MAGICFRAME --->> amf_net1
02:05:34.439 N udm2_c ---- SETTINGSFRAME --->> amf_net1
02:05:34.439 N udm2_c ---- WINDOWUPDATEFRAME --->> amf_net1


** iota SDL state machine
 *.sd file syntax is defined here: iota/ctpapp/lte/wiseiota/sim/hdr/sdlmacs.h
   SDL_SUCCESS        : value returned to SMD when NEXTSTATE is executed   
   SDL_DFLT           : value returned when current state of the SDL       does not handle the current message (the SDL       
                        Machine Driver (SMD) will then call the model's    'star state' function)                             
   SDL_NXSST          : macro for NEXTSTATE statement when same state is specified (e.g., NEXTSTATE - ;)

** coredump cathing
*** where is the core file generated
sysctl -a |grep core
kernel.core_pattern

ltemme@lm191:/local/ltemme/iota/test/msgtest $ sysctl -a |grep core_pattern
kernel.core_pattern = /var/core/%h-%e-%p.core

*** generate core files without limits
ulimit -c unlimited

*** stack size
ulimit -s 6144   ### runiotaflex for regression testing
ulimit -s 2048   ### runiota for our own msg test

* IOTA http2 uplayer message encdoe/decode 
** iota support different type but the same json name and field name
udm16.msgd
in different set object:
        SHAREDSMSSUBSDATAID             :       sharedSmsSubsDataIdNoNameArr            -O

        SHAREDSMSSUBSDATAID             :       sharedSmsSubsDataIdOneOf        -O

**
 set:sharedSmsSubsDataIdOneOf
        set desc "Shared SMS Subscription Data ID OneOf"
        set jsontype "object"
        set jsonname "sharedSmsSubsDataId"
        set class "SBAOneOf"
begin
        SHAREDSMSSUBSDATAIDSTR          :       sharedSmsSubsDataIdNoNameStr            -O
        SHAREDSMSSUBSDATAIDARR          :       sharedSmsSubsDataIdNoNameArr            -O
end


list:sharedSmsSubsDataIdNoNameArr
        set desc "Shared SMS Subscribption Data ID List"
        set jsontype "array"
        set jsonname "ignore"
begin
        SHAREDDATAIDARR :       sharedDataIdNoNameStr
end

** http2 decode
*** sbi interface 
20:46:36.730 N Enter processDataFrame
20:46:36.730 N decodeDataPayload: Enter
20:46:36.730 N decodeDataPayload: connname=http2simhttp2sut
20:46:36.730 N msgtype = 12
20:46:36.730 N setGlblContentType: connname=http2simhttp2sut
20:46:36.730 N setGlblContentType: http2_content_type_decode=json
20:46:36.730 N setGlblContentType: multipart_boundary_decode=EMPTY
20:46:36.730 N ftntype = udm, srvname = nudm-uecm
20:46:36.730 N srvversion = 16:1.1.3, release = 16
20:46:36.730 N Entering GPD::Sequence::decodeField(BODY)
20:46:36.730 N endPos = 875
20:46:36.730 N input->cur = 0
20:46:36.730 N GPD::Choice::decode
20:46:36.730 N GPD::Choice::decode _idflddef is set
20:46:36.730 N GPD::Choice::decode p->id/idv = 12
20:46:36.730 N Enter SBASet::decode, max = 876
20:46:36.730 N seqLen = 875
20:46:36.730 N input->cur = 0
20:46:36.730 N Enter SBASet::decodeField
20:46:36.730 N starting input->cur = 0
20:46:36.730 N endPos = 875
20:46:36.730 N _jsonType = message
20:46:36.730 N _jsonName = UECMUpdateAmfRegistrationReq

***  xml decode
0:30:12.525 N Enter processDataFrame
20:30:12.525 N decodeDataPayload: Enter
20:30:12.525 N decodeDataPayload: connname=http2simhttp2sut
20:30:12.525 N ftntype = admf, srvname = X1
20:30:12.525 N messagename =ModifyTaskResponse
20:30:12.525 N msgtype = 19
20:30:12.525 N  dataval with message type:


** http1 decode
20:15:18.462 B [http1sim.http1rtr:(135.111.25.169:60382|19:1485)] http1sim.http1rtr handle message internal = FALSE
20:15:18.462 N Data payload length = 658
20:15:18.462 N decodeDatareqPayload: Enter
20:15:18.462 N decodeDatareqPayload: connname=http1simhttp1sut
20:15:18.462 N messagename =ActivateTaskResponse

* iota AKA implementation
** log 
----------------------------
 AKA_UE::computeKnas5g enter 
 ItclAKAComputeKnas5gExt
-------------------------

** source code
AKA.tcl:
-----------------------------------------
::itcl::body AKA_UE::computeKnas5g {} {
    trace_
    log "AKA_UE::computeKnas5g enter"
        set _params(isUe)  "true"
    do_computeKnas5g
}
----------------
./ctpapp/lte/umts/scripting/AKA.tcl:134:       
 protected method do_computeKnas5g {}            @AKA-computeKnas5g  ### @<symbol> is meaningful here in addmethod
./ctpapp/lte/umts/scripting/AKAScriptProxy.C:4082:
    if (ie->addMethod("AKA-computeKnas5g",         ItclAKAComputeKnas5gExt) != TCL_OK) {
--------------
when AKA_UE::computeKnas5g was called, ItclAKAComputeKnas5gExt will be invoked.

* iota testcase scripting
**  add_msg_filter
 If you want to send this message during any IOTA procedure, you can use interactive IOTA and setup a filter to send this message when IOTA receives any specific message.   For example to send this 5GMMSTATUS message when CMM sends any INITIALCONTEXTSETUPREQUEST to IOTA, the command would be:

add_msg_filter -handlemsg INITIALCONTEXTSETUPREQUEST -send_msgname basic_snd_ngmmstatus_secure_tgt_amf -continue_processing true -send_from_sim gnb01 -tcl_commands { set ::c_ue(ngmmstatus_mmcause) 20; ::ueAKA mkSecurityHeader ::c_ue; ::ueAKA incrNasCount}


** AKA_UE
After that I was able to successfully send the message from IOTA using the following commands (after UE 5gRegistrationSUCI and 5gPduEstablishment):
Iota> set ::c_ue(ngmmstatus_mmcause) 20
Iota> ueAKA mkSecurityHeader ::c_ue
Iota> ueAKA incrNasCount;
Iota> 5gSendAsyncMsg -msg_name basic_snd_ngmmstatus_secure_tgt_amf -sim_name gnb01
 
::itcl::body AKA_UE::mkSecurityHeader

*** mapped security context
in iota case:
----------------------------------------
set ::c_ue(kasme) $::c_ue(contextrsp_n26_uemmcontext_kasme)
catch {delete obj ueAKA}
AKA_UE ::ueAKA ue1
ueAKA computeKasmeToKamf ::c_ue    ## compute Kamf from kasme for mapping security context
-----------------------------------

** debug iota  state machine: showscripts
                "waitfor_DETERMINELOCATIONREQUEST" {                                                                                                  switch $msgType {
                                "DETERMINELOCATIONREQ" {
        |       |       |       |       puts "xabcd"
        |       |       |       |       puts "[scen_common_chain showscripts]"

useMTDB db


* itcl syntax
itcl will define a class object very similar C++, constructor, destructor, method, proc
proc is similar to method, but it can be refered without class object or class name.

::itcl::class Scenario {
      inherit Documentable
      constructor {script {mtdb ""}} ### the first layer is argument list {script mtdb}
                                     ### when mtdb need a default value, then use {mtdb ""} instead of mtdb
      ### this is the body of the constructor
      {
                trace_
                ::set _script $script
                ::set _MTDB $mtdb
                ::set _MSGQUEUE [MessageQueue #auto ]
        }

usage of the class:
-------------
Scenario nssf_r16_test {
    useMTDB db  ### this useMTDB is the method of Scenario class
    set ::c_ue(data_flags)  1..
    send ...
} db
-----------------------
the the instance of class Scenario is nssf_r16_test, and the first argument script is within the "{}", the second 
argument is db with sapce seperated with the first argument, so this is the create and initialization of the object.
-----------------------
nssf_r16_test start  ### the start is a method of the Scenario class, 
------------------------
--------------------------------------
::itcl::body Scenario::start {} {
        trace_
        $_MSGQUEUE setWorkMode 1
        cleanup
        if {([catch { eval $_script  ### evaluate the script passed
-----------------------------------
